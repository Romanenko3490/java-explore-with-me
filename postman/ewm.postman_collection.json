{
	"info": {
		"_postman_id": "faecb0bc-2033-4479-87c9-9a2b1129aee8",
		"name": "ewm",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "45515798",
		"_collection_link": "https://german-6705617.postman.co/workspace/German's-Workspace~63c0fd15-9840-48e5-8f23-c9340cfdad4c/collection/45515798-faecb0bc-2033-4479-87c9-9a2b1129aee8?action=share&source=collection_link&creator=45515798"
	},
	"item": [
		{
			"name": "stats",
			"item": [
				{
					"name": "Successfull add hit",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"pm.test(\"Status code is 201 Created\", function () {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"\r",
									"pm.test(\"Response body is empty\", function () {\r",
									"    const responseText = pm.response.text();\r",
									"    pm.expect(responseText).to.be.empty;\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"app\": \"ewm-main-service\",\n  \"uri\": \"/events/1\",\n  \"ip\": \"192.163.0.1\",\n  \"timestamp\": \"2022-09-06 11:00:23\"\n}"
						},
						"url": {
							"raw": "{{base_url}}/hit",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"hit"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get stats within dates without uri and not unique",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const start = pm.environment.get(\"start\");\r",
									"\r",
									"const fixedTimestamp = \"2025-10-07 12:00:00\";\r",
									"\r",
									"const hits = [\r",
									"    { app: \"test-app\", uri: \"/a\", ip: \"192.168.1.1\", timestamp: fixedTimestamp },\r",
									"    { app: \"test-app\", uri: \"/a\", ip: \"192.168.1.2\", timestamp: fixedTimestamp },\r",
									"    { app: \"test-app\", uri: \"/a\", ip: \"192.168.1.3\", timestamp: fixedTimestamp },\r",
									"    \r",
									"    { app: \"test-app\", uri: \"/b\", ip: \"192.168.2.1\", timestamp: fixedTimestamp },\r",
									"    { app: \"test-app\", uri: \"/b\", ip: \"192.168.2.2\", timestamp: fixedTimestamp },\r",
									"    \r",
									"    { app: \"test-app\", uri: \"/c\", ip: \"192.168.3.1\", timestamp: fixedTimestamp }\r",
									"];\r",
									"\r",
									"function sendHit(index) {\r",
									"    if (index >= hits.length) {\r",
									"        // Ждём 1 секунду, чтобы сервер успел сохранить\r",
									"        setTimeout(() => {}, 1000);\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const hit = hits[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/hit`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(hit)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка:\", err);\r",
									"        }\r",
									"        sendHit(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"sendHit(0);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const jsonData = pm.response.json();\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(jsonData)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Response contains 3 URIs\", function () {\r",
									"    pm.expect(jsonData.length).to.eql(3);\r",
									"});\r",
									"\r",
									"jsonData.forEach(item => {\r",
									"    pm.expect(item).to.include.all.keys('app', 'uri', 'hits');\r",
									"    pm.expect(item.app).to.eql(\"test-app\");\r",
									"    pm.expect(item.hits).to.be.a('number').and.to.be.above(0);\r",
									"});\r",
									"\r",
									"pm.test(\"Results are sorted by hits descending\", function () {\r",
									"    for (let i = 0; i < jsonData.length - 1; i++) {\r",
									"        pm.expect(jsonData[i].hits).to.be.at.least(jsonData[i + 1].hits);\r",
									"    }\r",
									"});\r",
									"\r",
									"const expected = [\r",
									"    { uri: \"/a\", hits: 3 },\r",
									"    { uri: \"/b\", hits: 2 },\r",
									"    { uri: \"/c\", hits: 1 }\r",
									"];\r",
									"\r",
									"pm.test(\"Exact hit counts match expected values\", function () {\r",
									"    for (let i = 0; i < expected.length; i++) {\r",
									"        pm.expect(jsonData[i].uri).to.eql(expected[i].uri);\r",
									"        pm.expect(jsonData[i].hits).to.eql(expected[i].hits);\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/stats?start={{start}}&end={{end}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"stats"
							],
							"query": [
								{
									"key": "start",
									"value": "{{start}}"
								},
								{
									"key": "end",
									"value": "{{end}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Gets stats within dates with uri and not unique",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const start = pm.environment.get(\"start\");\r",
									"const fixedTimestamp = \"2025-10-07 12:00:00\";\r",
									"\r",
									"const hits = [\r",
									"    { app: \"test-app\", uri: \"/x\", ip: \"10.0.0.1\", timestamp: fixedTimestamp },\r",
									"    { app: \"test-app\", uri: \"/x\", ip: \"10.0.0.2\", timestamp: fixedTimestamp },\r",
									"    { app: \"test-app\", uri: \"/x\", ip: \"10.0.0.3\", timestamp: fixedTimestamp },\r",
									"    \r",
									"    { app: \"test-app\", uri: \"/y\", ip: \"10.0.1.1\", timestamp: fixedTimestamp },\r",
									"    { app: \"test-app\", uri: \"/y\", ip: \"10.0.1.2\", timestamp: fixedTimestamp }\r",
									"];\r",
									"\r",
									"function sendHit(index) {\r",
									"    if (index >= hits.length) {\r",
									"        setTimeout(() => {}, 1000);\r",
									"        return;\r",
									"    }\r",
									"    const hit = hits[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/hit`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(hit)\r",
									"    }, function (err, res) {\r",
									"        if (err) console.error(\"Ошибка:\", err);\r",
									"        sendHit(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"sendHit(0);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has exactly 2 items: /x and /y\", function () {\r",
									"    pm.expect(jsonData.length).to.eql(2);\r",
									"    const uris = jsonData.map(x => x.uri);\r",
									"    pm.expect(uris).to.include(\"/x\");\r",
									"    pm.expect(uris).to.include(\"/y\");\r",
									"\r",
									"    pm.expect(uris).to.not.include(\"/a\");\r",
									"    pm.expect(uris).to.not.include(\"/b\");\r",
									"    pm.expect(uris).to.not.include(\"/c\");\r",
									"});\r",
									"\r",
									"pm.test(\"Hit counts are correct\", function () {\r",
									"    const x = jsonData.find(x => x.uri === \"/x\");\r",
									"    const y = jsonData.find(x => x.uri === \"/y\");\r",
									"    pm.expect(x.hits).to.eql(3);\r",
									"    pm.expect(y.hits).to.eql(2);\r",
									"});\r",
									"\r",
									"pm.test(\"Sorted by hits descending\", function () {\r",
									"    pm.expect(jsonData[0].uri).to.eql(\"/x\");\r",
									"    pm.expect(jsonData[1].uri).to.eql(\"/y\");\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/stats?start={{start}}&end={{end}}&uris=/x&uris=/y",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"stats"
							],
							"query": [
								{
									"key": "start",
									"value": "{{start}}"
								},
								{
									"key": "end",
									"value": "{{end}}"
								},
								{
									"key": "uris",
									"value": "/x"
								},
								{
									"key": "uris",
									"value": "/y"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Get stats within dates with uri and unique true",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const fixedTimestamp = \"2025-10-07 12:00:00\";\r",
									"\r",
									"const hits = [\r",
									"    { app: \"test-app\", uri: \"/u\", ip: \"172.16.0.1\", timestamp: fixedTimestamp },\r",
									"    { app: \"test-app\", uri: \"/u\", ip: \"172.16.0.1\", timestamp: fixedTimestamp },\r",
									"    { app: \"test-app\", uri: \"/u\", ip: \"172.16.0.2\", timestamp: fixedTimestamp },\r",
									"    { app: \"test-app\", uri: \"/v\", ip: \"172.16.1.1\", timestamp: fixedTimestamp },\r",
									"    { app: \"test-app\", uri: \"/v\", ip: \"172.16.1.1\", timestamp: fixedTimestamp },\r",
									"    { app: \"test-app\", uri: \"/v\", ip: \"172.16.1.1\", timestamp: fixedTimestamp }\r",
									"];\r",
									"\r",
									"function sendHit(index) {\r",
									"    if (index >= hits.length) {\r",
									"        setTimeout(() => {}, 1000);\r",
									"        return;\r",
									"    }\r",
									"    const hit = hits[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/hit`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(hit)\r",
									"    }, function (err, res) {\r",
									"        if (err) console.error(\"Ошибка:\", err);\r",
									"        sendHit(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"sendHit(0);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has /u and /v only\", function () {\r",
									"    pm.expect(jsonData.length).to.eql(2);\r",
									"    const uris = jsonData.map(x => x.uri);\r",
									"    pm.expect(uris).to.include(\"/u\");\r",
									"    pm.expect(uris).to.include(\"/v\");\r",
									"});\r",
									"\r",
									"pm.test(\"Unique counts: /u=2, /v=1\", function () {\r",
									"    const u = jsonData.find(x => x.uri === \"/u\");\r",
									"    const v = jsonData.find(x => x.uri === \"/v\");\r",
									"    pm.expect(u.hits).to.eql(2);\r",
									"    pm.expect(v.hits).to.eql(1);\r",
									"});\r",
									"\r",
									"pm.test(\"Sorted descending\", function () {\r",
									"    pm.expect(jsonData[0].uri).to.eql(\"/u\");\r",
									"    pm.expect(jsonData[1].uri).to.eql(\"/v\");\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/stats?start={{start}}&end={{end}}&unique=true&uris=/u&uris=/v",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"stats"
							],
							"query": [
								{
									"key": "start",
									"value": "{{start}}"
								},
								{
									"key": "end",
									"value": "{{end}}"
								},
								{
									"key": "unique",
									"value": "true"
								},
								{
									"key": "uris",
									"value": "/u"
								},
								{
									"key": "uris",
									"value": "/v"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "admin",
			"item": [
				{
					"name": "Add success user",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const timestamp = Date.now();\r",
									"\r",
									"// Генерируем уникальные данные\r",
									"const email = `user_${timestamp}@test.com`;\r",
									"const name = `Test User ${timestamp}`;\r",
									"\r",
									"// Сохраняем в переменные, чтобы использовать в запросе\r",
									"pm.variables.set(\"test_email\", email);\r",
									"pm.variables.set(\"test_name\", name);\r",
									"\r",
									"console.log(\"Generated email:\", email);\r",
									"console.log(\"Generated name:\", name);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 201 Created\", function () {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.include.all.keys('id', 'email', 'name');\r",
									"});\r",
									"\r",
									"pm.test(\"Email matches generated value\", function () {\r",
									"    pm.expect(response.email).to.eql(pm.variables.get(\"test_email\"));\r",
									"});\r",
									"\r",
									"pm.test(\"Name matches generated value\", function () {\r",
									"    pm.expect(response.name).to.eql(pm.variables.get(\"test_name\"));\r",
									"});\r",
									"\r",
									"pm.test(\"ID is a number\", function () {\r",
									"    pm.expect(response.id).to.be.a('number');\r",
									"    pm.expect(response.id).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"// Проверим, что email содержит \"@test.com\"\r",
									"pm.test(\"Email format is correct\", function () {\r",
									"    pm.expect(response.email).to.include('@test.com');\r",
									"});\r",
									"\r",
									"// Проверим, что имя содержит \"Test User\"\r",
									"pm.test(\"Name format is correct\", function () {\r",
									"    pm.expect(response.name).to.include('Test User');\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"email\": \"{{test_email}}\",\n  \"name\": \"{{test_name}}\"\n}"
						},
						"url": {
							"raw": "{{base_url}}/admin/users",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"users"
							]
						}
					},
					"response": []
				},
				{
					"name": "Add user with dublicate email",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// Генерируем уникальные данные\r",
									"const email = `duplicate_${timestamp}@test.com`;\r",
									"const name1 = `First User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: email, name: name1 })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании первого пользователя:\", err);\r",
									"    } else {\r",
									"        console.log(\"Первый пользователь создан, статус:\", res.code);\r",
									"        // Сохраняем email для основного запроса\r",
									"        pm.variables.set(\"test_email\", email);\r",
									"        pm.variables.set(\"test_name\", name1);\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 409 Conflict\", function () {\r",
									"    pm.response.to.have.status(409);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is CONFLICT\", function () {\r",
									"    pm.expect(response.status).to.eql(\"CONFLICT\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Integrity constraint has been violated.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Integrity constraint has been violated.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message contains email and conflict prefix\", function () {\r",
									"    const message = response.message;\r",
									"    const email = pm.variables.get(\"test_email\");\r",
									"\r",
									"    // Проверяем, что сообщение начинается с \"Conflict from service: \"\r",
									"    pm.expect(message).to.include(\"Conflict from service: \");\r",
									"    // Проверяем, что содержит email\r",
									"    pm.expect(message).to.include(email);\r",
									"    // Проверяем, что содержит остальную часть сообщения\r",
									"    pm.expect(message).to.include(\"constraint \");\r",
									"    pm.expect(message).to.include(\"nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement\");\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    // Проверяем формат \"yyyy-MM-dd HH:mm:ss\"\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"email\": \"{{test_email}}\",\r\n  \"name\": \"Second User {{timestamp}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/users",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"users"
							]
						}
					},
					"response": []
				},
				{
					"name": "Add user with empty email",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"pm.test(\"Status code is 400 Bad Request\", function () {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has required fields\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is BAD_REQUEST\", function () {\r",
									"    pm.expect(response.status).to.eql(\"BAD_REQUEST\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is correct\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Incorrectly made request.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message matches expected\", function () {\r",
									"    const expectedMessage = \"Field: email. Error: must not be blank. Value: \";\r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is a valid ISO string\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"email\": \"\",\r\n  \"name\": \"Test User\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/users",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"users"
							]
						}
					},
					"response": []
				},
				{
					"name": "Add user with blank email",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 Bad Request\", function () {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has required fields\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is BAD_REQUEST\", function () {\r",
									"    pm.expect(response.status).to.eql(\"BAD_REQUEST\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is correct\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Incorrectly made request.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message contains exact value with space\", function () {\r",
									"    // Ожидаем: \"Field: email. Error: must not be blank. Value:  \"\r",
									"    // Обрати внимание: после \"Value: \" идёт один пробел перед закрывающей кавычкой\r",
									"    const expectedMessage = \"Field: email. Error: must be a well-formed email address. Value:  \";\r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"email\": \" \",\r\n  \"name\": \"Test User\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/users",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"users"
							]
						}
					},
					"response": []
				},
				{
					"name": "Add user with wrong email",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 Bad Request\", function () {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has required fields\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is BAD_REQUEST\", function () {\r",
									"    pm.expect(response.status).to.eql(\"BAD_REQUEST\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is correct\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Incorrectly made request.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message matches expected for invalid email\", function () {\r",
									"    const expectedMessage = \"Field: email. Error: must be a well-formed email address. Value: wrongemail\";\r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is a valid ISO string\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"email\": \"wrongemail\",\r\n  \"name\": \"Test User\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/users",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"users"
							]
						}
					},
					"response": []
				},
				{
					"name": "Add user with Empty Name",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 Bad Request\", function () {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has required fields\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is BAD_REQUEST\", function () {\r",
									"    pm.expect(response.status).to.eql(\"BAD_REQUEST\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is correct\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Incorrectly made request.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message matches expected for blank name\", function () {\r",
									"    const expectedMessage = \"Field: name. Error: must not be blank. Value: \";\r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is a valid ISO string\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"email\": \"valid@example.com\",\r\n  \"name\": \"\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/users",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"users"
							]
						}
					},
					"response": []
				},
				{
					"name": "Add user with blank name",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 Bad Request\", function () {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has required fields\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is BAD_REQUEST\", function () {\r",
									"    pm.expect(response.status).to.eql(\"BAD_REQUEST\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is correct\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Incorrectly made request.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message matches expected for name with space\", function () {\r",
									"    const expectedMessage = \"Field: name. Error: must not be blank. Value:  \";\r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is a valid ISO string\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"email\": \"valid@example.com\",\r\n  \"name\": \" \"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/users",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"users"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get users by ids successfully",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"const timestamp = Date.now();\r",
									"const users = [\r",
									"    { email: `user1_${timestamp}@test.com`, name: \"User One\" },\r",
									"    { email: `user2_${timestamp}@test.com`, name: \"User Two\" },\r",
									"    { email: `user3_${timestamp}@test.com`, name: \"User Three\" }\r",
									"];\r",
									"\r",
									"const createdIds = [];\r",
									"\r",
									"function createUser(index) {\r",
									"    if (index >= users.length) {\r",
									"        const idsParam = createdIds.join(',');\r",
									"        const fullUrl = `${baseUrl}/admin/users?ids=${idsParam}&from=0&size=10`;\r",
									"        pm.variables.set(\"dynamic_url\", fullUrl);\r",
									"        console.log(\"Generated URL:\", fullUrl);\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const user = users[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/users`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(user)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            createdIds.push(response.id);\r",
									"        }\r",
									"        createUser(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"createUser(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(response)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Response has 3 users\", function () {\r",
									"    pm.expect(response.length).to.eql(3);\r",
									"});\r",
									"\r",
									"const url = pm.request.url.toString();\r",
									"const idsMatch = url.match(/ids=([^&]+)/);\r",
									"if (idsMatch) {\r",
									"    const expectedIds = idsMatch[1].split(',').map(Number);\r",
									"\r",
									"    pm.test(\"All requested IDs are present\", function () {\r",
									"        const responseIds = response.map(user => user.id);\r",
									"        pm.expect(responseIds).to.have.members(expectedIds);\r",
									"    });\r",
									"}\r",
									"\r",
									"response.forEach(user => {\r",
									"    pm.test(`User ${user.id} has correct structure`, function () {\r",
									"        pm.expect(user).to.include.all.keys('id', 'name', 'email');\r",
									"        pm.expect(user.id).to.be.a('number');\r",
									"        pm.expect(user.name).to.be.a('string');\r",
									"        pm.expect(user.email).to.be.a('string');\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{dynamic_url}}",
							"host": [
								"{{dynamic_url}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get users with absent ids",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(response)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Response is empty (no users found)\", function () {\r",
									"    pm.expect(response.length).to.eql(0);\r",
									"});\r",
									"\r",
									"pm.test(\"Response is exactly []\", function () {\r",
									"    pm.expect(response).to.eql([]);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/admin/users?ids=999,1000,1001",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"users"
							],
							"query": [
								{
									"key": "ids",
									"value": "999,1000,1001"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Get users in range 1 - 10",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// Генерируем 11 уникальных пользователей\r",
									"const users = [];\r",
									"for (let i = 1; i <= 11; i++) {\r",
									"    users.push({\r",
									"        email: `user${i}_${timestamp}@test.com`,\r",
									"        name: `User ${i} ${timestamp}`\r",
									"    });\r",
									"}\r",
									"\r",
									"const createdIds = [];\r",
									"\r",
									"function createUser(index) {\r",
									"    if (index >= users.length) {\r",
									"        // Сохраняем id первых 10 пользователей (ожидаем, что они вернутся)\r",
									"        const expectedIds = createdIds.slice(0, 10);\r",
									"        pm.variables.set(\"expected_ids\", expectedIds.join(','));\r",
									"        console.log(\"Created 11 users, expected first 10 IDs:\", expectedIds);\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const user = users[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/users`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(user)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            createdIds.push(response.id);\r",
									"        }\r",
									"        createUser(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"createUser(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(response)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Response has exactly 10 users (pagination default)\", function () {\r",
									"    pm.expect(response.length).to.eql(10);\r",
									"});\r",
									"\r",
									"pm.test(\"User IDs are sequential starting from 1\", function () {\r",
									"    const responseIds = response.map(user => user.id);\r",
									"    const expectedIds = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r",
									"    pm.expect(responseIds).to.eql(expectedIds);\r",
									"});\r",
									"\r",
									"// Проверка структуры каждого пользователя\r",
									"response.forEach(user => {\r",
									"    pm.test(`User ${user.id} has correct structure`, function () {\r",
									"        pm.expect(user).to.include.all.keys('id', 'name', 'email');\r",
									"        pm.expect(user.id).to.be.a('number');\r",
									"        pm.expect(user.name).to.be.a('string');\r",
									"        pm.expect(user.email).to.be.a('string');\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{base_url}}/admin/users",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"users"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get users from  5 size 5",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(response)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Response has 5 users\", function () {\r",
									"    pm.expect(response.length).to.eql(5);\r",
									"});\r",
									"\r",
									"// Проверяем, что id идут подряд: 6, 7, 8, 9, 10 (если сервер возвращает по возрастанию id)\r",
									"pm.test(\"User IDs are 6, 7, 8, 9, 10\", function () {\r",
									"    const expectedIds = [6, 7, 8, 9, 10];\r",
									"    const responseIds = response.map(user => user.id);\r",
									"    pm.expect(responseIds).to.eql(expectedIds);\r",
									"});\r",
									"\r",
									"// Проверка структуры каждого пользователя\r",
									"response.forEach(user => {\r",
									"    pm.test(`User ${user.id} has correct structure`, function () {\r",
									"        pm.expect(user).to.include.all.keys('id', 'name', 'email');\r",
									"        pm.expect(user.id).to.be.a('number');\r",
									"        pm.expect(user.name).to.be.a('string');\r",
									"        pm.expect(user.email).to.be.a('string');\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/admin/users?from=5&size=5",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"users"
							],
							"query": [
								{
									"key": "from",
									"value": "5"
								},
								{
									"key": "size",
									"value": "5"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Get users with wrong request",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 Bad Request\", function () {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has exact structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is BAD_REQUEST\", function () {\r",
									"    pm.expect(response.status).to.eql(\"BAD_REQUEST\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Incorrectly made request.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Incorrectly made request.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message matches exactly\", function () {\r",
									"    const expectedMessage = \"Failed to convert value of type 'java.lang.String' to required type 'java.lang.Integer'; For input string: \\\"invalid\\\"\";\r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    // Проверим, что это валидный формат даты\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    // И что формат соответствует \"yyyy-MM-dd HH:mm:ss\" (если сервер так возвращает)\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/admin/users?from=invalid&size=notnumber",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"users"
							],
							"query": [
								{
									"key": "from",
									"value": "invalid"
								},
								{
									"key": "size",
									"value": "notnumber"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete success user",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"const user = {\r",
									"    email: `user_${timestamp}@test.com`,\r",
									"    name: `User ${timestamp}`\r",
									"};\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify(user)\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const response = res.json();\r",
									"        const userId = response.id;\r",
									"        pm.variables.set(\"user_id\", userId);\r",
									"        console.log(\"Создан пользователь с ID:\", userId);\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 204 No Content\", function () {\r",
									"    pm.response.to.have.status(204);\r",
									"});\r",
									"\r",
									"pm.test(\"Response body is empty\", function () {\r",
									"    pm.expect(pm.response.text()).to.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Response has no content\", function () {\r",
									"    // Проверяем, что Content-Length = 0 или Content-Type не указан\r",
									"    const contentLength = pm.response.headers.get(\"Content-Length\");\r",
									"    pm.expect(contentLength).to.be.oneOf([\"0\", null, undefined]);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "DELETE",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{base_url}}/admin/users/{{user_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"users",
								"{{user_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete absent user",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 404 Not Found\", function () {\r",
									"    pm.response.to.have.status(404);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has exact structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is NOT_FOUND\", function () {\r",
									"    pm.expect(response.status).to.eql(\"NOT_FOUND\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is The required object was not found.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"The required object was not found.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message matches exactly\", function () {\r",
									"    const expectedMessage = \"User with id=999 was not found\";\r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    // Проверяем формат \"yyyy-MM-dd HH:mm:ss\"\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{base_url}}/admin/users/999",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"users",
								"999"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete user with wrong request",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 Bad Request\", function () {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has exact structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is BAD_REQUEST\", function () {\r",
									"    pm.expect(response.status).to.eql(\"BAD_REQUEST\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Incorrectly made request.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Incorrectly made request.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message matches exactly\", function () {\r",
									"    const expectedMessage = \"Field: deleteUser.id. Error: must be greater than or equal to 1. Value: -1\";\r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    // Проверяем формат \"yyyy-MM-dd HH:mm:ss\"\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{base_url}}/admin/users/-1",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"users",
								"-1"
							]
						}
					},
					"response": []
				},
				{
					"name": "Add valid category",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const timestamp = Date.now();\r",
									"const randomName = `Category ${timestamp}`;\r",
									"pm.variables.set(\"category_name\", randomName);\r",
									"console.log(\"Generated category name:\", randomName);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 201 Created\", function () {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.include.all.keys('id', 'name');\r",
									"});\r",
									"\r",
									"pm.test(\"Name matches generated value\", function () {\r",
									"    pm.expect(response.name).to.eql(pm.variables.get(\"category_name\"));\r",
									"});\r",
									"\r",
									"pm.test(\"ID is a number\", function () {\r",
									"    pm.expect(response.id).to.be.a('number');\r",
									"    pm.expect(response.id).to.be.greaterThan(0);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{category_name}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/categories",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"categories"
							]
						}
					},
					"response": []
				},
				{
					"name": "Add empty name category",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 Bad Request\", function () {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is BAD_REQUEST\", function () {\r",
									"    pm.expect(response.status).to.eql(\"BAD_REQUEST\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Incorrectly made request.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Incorrectly made request.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message matches expected for blank name\", function () {\r",
									"    const expectedMessage = \"Field: name. Error: must not be blank. Value: \";\r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    // Проверяем формат \"yyyy-MM-dd HH:mm:ss\"\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"name\" : \"\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/categories",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"categories"
							]
						}
					},
					"response": []
				},
				{
					"name": "Add blank name category",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 Bad Request\", function () {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is BAD_REQUEST\", function () {\r",
									"    pm.expect(response.status).to.eql(\"BAD_REQUEST\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Incorrectly made request.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Incorrectly made request.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message matches expected for space-only name\", function () {\r",
									"    const expectedMessage = \"Field: name. Error: must not be blank. Value:  \";\r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    // Проверяем формат \"yyyy-MM-dd HH:mm:ss\"\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"name\" : \" \"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/categories",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"categories"
							]
						}
					},
					"response": []
				},
				{
					"name": "Added already existed category",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// Генерируем уникальное имя\r",
									"const categoryName = `Category ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/categories`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ name: categoryName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании первой категории:\", err);\r",
									"    } else {\r",
									"        console.log(\"Первая категория создана, статус:\", res.code);\r",
									"        // Сохраняем имя для основного запроса\r",
									"        pm.variables.set(\"category_name\", categoryName);\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 409 Conflict\", function () {\r",
									"    pm.response.to.have.status(409);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is CONFLICT\", function () {\r",
									"    pm.expect(response.status).to.eql(\"CONFLICT\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Integrity constraint has been violated.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Integrity constraint has been violated.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message contains category name and conflict prefix\", function () {\r",
									"    const message = response.message;\r",
									"    const categoryName = pm.variables.get(\"category_name\");\r",
									"\r",
									"    // Проверяем, что сообщение начинается с \"Conflict from service: \"\r",
									"    pm.expect(message).to.include(\"Conflict from service: \");\r",
									"    // Проверяем, что содержит название категории\r",
									"    pm.expect(message).to.include(categoryName);\r",
									"    // Проверяем, что содержит остальную часть сообщения\r",
									"    pm.expect(message).to.include(\"constraint \");\r",
									"    pm.expect(message).to.include(\"nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement\");\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    // Проверяем формат \"yyyy-MM-dd HH:mm:ss\"\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{category_name}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/categories",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"categories"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update valid category",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// Генерируем уникальное имя\r",
									"const categoryName = `Category ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/categories`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ name: categoryName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании категории:\", err);\r",
									"    } else {\r",
									"        const response = res.json();\r",
									"        console.log(\"Категория создана, ID:\", response.id);\r",
									"        // Сохраняем id и имя для основного запроса\r",
									"        pm.variables.set(\"category_id\", response.id);\r",
									"        pm.variables.set(\"original_name\", categoryName);\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.include.all.keys('id', 'name');\r",
									"});\r",
									"\r",
									"pm.test(\"ID matches original category\", function () {\r",
									"    pm.expect(response.id).to.eql(Number(pm.variables.get(\"category_id\")));\r",
									"});\r",
									"\r",
									"pm.test(\"Name is updated\", function () {\r",
									"    pm.expect(response.name).to.eql(\"Updated Category Name\");\r",
									"});\r",
									"\r",
									"pm.test(\"Name is not original\", function () {\r",
									"    const originalName = pm.variables.get(\"original_name\");\r",
									"    pm.expect(response.name).to.not.eql(originalName);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"Updated Category Name\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/categories/{{category_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"categories",
								"{{category_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update absen category",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 404 Not Found\", function () {\r",
									"    pm.response.to.have.status(404);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is NOT_FOUND\", function () {\r",
									"    pm.expect(response.status).to.eql(\"NOT_FOUND\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is The required object was not found.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"The required object was not found.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message matches expected format\", function () {\r",
									"    const expectedMessage = \"Not found from service: Category with id=999 was not found\";\r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    // Проверяем формат \"yyyy-MM-dd HH:mm:ss\"\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"Updated Category Name\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/categories/999",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"categories",
								"999"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update Category with existed name",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// Генерируем уникальные имена\r",
									"const categoryName1 = `Category 1 ${timestamp}`;\r",
									"const categoryName2 = `Category 2 ${timestamp}`;\r",
									"\r",
									"// Массив для хранения id созданных категорий\r",
									"const createdIds = [];\r",
									"\r",
									"function createCategory(index) {\r",
									"    if (index >= 2) {\r",
									"        // Сохраняем id обеих созданных категорий\r",
									"        pm.variables.set(\"category_id_1\", createdIds[0]);\r",
									"        pm.variables.set(\"category_id_2\", createdIds[1]);\r",
									"        pm.variables.set(\"category_name_1\", categoryName1);\r",
									"        pm.variables.set(\"category_name_2\", categoryName2);\r",
									"        console.log(\"Created categories:\", createdIds);\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const name = index === 0 ? categoryName1 : categoryName2;\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/categories`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({ name: name })\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании категории:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            createdIds.push(response.id);\r",
									"        }\r",
									"        createCategory(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"createCategory(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 409 Conflict\", function () {\r",
									"    pm.response.to.have.status(409);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is CONFLICT\", function () {\r",
									"    pm.expect(response.status).to.eql(\"CONFLICT\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Integrity constraint has been violated.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Integrity constraint has been violated.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message contains conflict prefix and category name\", function () {\r",
									"    const message = response.message;\r",
									"    const expectedPrefix = \"Conflict from service: \";\r",
									"    const categoryName2 = pm.variables.get(\"category_name_2\");\r",
									"\r",
									"    // Проверяем, что сообщение начинается с \"Conflict from service: \"\r",
									"    pm.expect(message).to.include(expectedPrefix);\r",
									"    // Проверяем, что содержит имя второй категории\r",
									"    pm.expect(message).to.include(categoryName2);\r",
									"    // Проверяем, что содержит остальную часть сообщения\r",
									"    pm.expect(message).to.include(\"constraint \");\r",
									"    pm.expect(message).to.include(\"nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement\");\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    // Проверяем формат \"yyyy-MM-dd HH:mm:ss\"\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{category_name_2}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/categories/{{category_id_1}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"categories",
								"{{category_id_1}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete present category",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// Создаём новую категорию\r",
									"const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/categories`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ name: categoryName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании категории:\", err);\r",
									"    } else {\r",
									"        const category = res.json();\r",
									"        console.log(\"Создана категория с ID:\", category.id);\r",
									"        \r",
									"        // Сохраняем id категории для удаления\r",
									"        pm.variables.set(\"category_id\", category.id);\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 204 No Content\", function () {\r",
									"    pm.response.to.have.status(204);\r",
									"});\r",
									"\r",
									"// Проверим, что категории больше нет\r",
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const categoryId = pm.variables.get(\"category_id\");\r",
									"\r",
									"pm.test(\"Category is deleted (try to get it)\", function () {\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/categories/${categoryId}`,\r",
									"        method: 'GET'\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при проверке удаления категории:\", err);\r",
									"        } else {\r",
									"            // Ожидаем 404, если категория удалена\r",
									"            pm.expect(res.code).to.eql(404);\r",
									"        }\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "DELETE",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{category_name}}\"\r\n}"
						},
						"url": {
							"raw": "{{base_url}}/admin/categories/{{category_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"categories",
								"{{category_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete used category",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// Шаг 1: Создаём нового пользователя\r",
									"const userEmail = `user_${timestamp}@test.com`;\r",
									"const userName = `Test User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const user = res.json();\r",
									"        console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"        // Шаг 2: Создаём новую категорию\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err2, res2) {\r",
									"            if (err2) {\r",
									"                console.error(\"Ошибка при создании категории:\", err2);\r",
									"            } else {\r",
									"                const category = res2.json();\r",
									"                console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"                // Шаг 3: Создаём событие с этой категорией\r",
									"                const eventPayload = {\r",
									"                    annotation: \"Test event for category deletion test\",\r",
									"                    category: category.id,\r",
									"                    description: \"This event is linked to the category we will try to delete\",\r",
									"                    eventDate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString().replace('T', ' ').substring(0, 19), // +3 дня\r",
									"                    location: {\r",
									"                        lat: 55.754167,\r",
									"                        lon: 37.62\r",
									"                    },\r",
									"                    paid: false,\r",
									"                    participantLimit: 0,\r",
									"                    requestModeration: false,\r",
									"                    title: `Test Event for Category ${category.id}`\r",
									"                };\r",
									"\r",
									"                pm.sendRequest({\r",
									"                    url: `${baseUrl}/users/${user.id}/events`,\r",
									"                    method: 'POST',\r",
									"                    header: { 'Content-Type': 'application/json' },\r",
									"                    body: JSON.stringify(eventPayload)\r",
									"                }, function (err3, res3) {\r",
									"                    if (err3) {\r",
									"                        console.error(\"Ошибка при создании события:\", err3);\r",
									"                    } else {\r",
									"                        const event = res3.json();\r",
									"                        console.log(\"Создано событие с ID:\", event.id);\r",
									"                        \r",
									"                        // Сохраняем id категории для удаления\r",
									"                        pm.variables.set(\"category_id\", category.id);\r",
									"                    }\r",
									"                });\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 409 Conflict\", function () {\r",
									"    pm.response.to.have.status(409);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is CONFLICT\", function () {\r",
									"    pm.expect(response.status).to.eql(\"CONFLICT\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is For the requested operation the conditions are not met.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"For the requested operation the conditions are not met.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message is 'The category is not empty'\", function () {\r",
									"    pm.expect(response.message).to.eql(\"The category is not empty\");\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    // Проверяем формат \"yyyy-MM-dd HH:mm:ss\"\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "DELETE",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{category_name}}\"\r\n}"
						},
						"url": {
							"raw": "{{base_url}}/admin/categories/{{category_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"categories",
								"{{category_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Admin seccesfully update event oublished",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// --- Шаг 1: Создание пользователя (инициатора события) ---\r",
									"const userEmail = `initiator_${timestamp}@test.com`;\r",
									"const userName = `Initiator User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const user = res.json();\r",
									"        console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"        // --- Шаг 2: Создание категории ---\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err2, res2) {\r",
									"            if (err2) {\r",
									"                console.error(\"Ошибка при создании категории:\", err2);\r",
									"            } else {\r",
									"                const category = res2.json();\r",
									"                console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"                // --- Шаг 3: Создание события в состоянии PENDING ---\r",
									"                // Дата события — через 3 часа от текущего момента\r",
									"                const futureDate = new Date(Date.now() + 3 * 60 * 60 * 1000);\r",
									"                const eventDateStr = futureDate.toISOString().replace('T', ' ').substring(0, 19);\r",
									"\r",
									"                const eventPayload = {\r",
									"                    annotation: \"Annotation for the test event to be published by admin.\",\r",
									"                    category: category.id,\r",
									"                    description: \"This is a detailed description of the test event. It will be published by the admin.\",\r",
									"                    eventDate: eventDateStr,\r",
									"                    location: {\r",
									"                        lat: 55.754167,\r",
									"                        lon: 37.62\r",
									"                    },\r",
									"                    paid: false,\r",
									"                    participantLimit: 0,\r",
									"                    requestModeration: true,\r",
									"                    title: \"Test Event For Admin Publish\"\r",
									"                };\r",
									"\r",
									"                pm.sendRequest({\r",
									"                    url: `${baseUrl}/users/${user.id}/events`,\r",
									"                    method: 'POST',\r",
									"                    header: { 'Content-Type': 'application/json' },\r",
									"                    body: JSON.stringify(eventPayload)\r",
									"                }, function (err3, res3) {\r",
									"                    if (err3) {\r",
									"                        console.error(\"Ошибка при создании события:\", err3);\r",
									"                    } else {\r",
									"                        const event = res3.json();\r",
									"                        console.log(\"Создано событие с ID:\", event.id);\r",
									"\r",
									"                        // --- Сохранение ID для основного запроса ---\r",
									"                        pm.variables.set(\"user_id\", user.id);\r",
									"                        pm.variables.set(\"category_id\", category.id);\r",
									"                        pm.variables.set(\"event_id\", event.id);\r",
									"                        // Для проверки в Tests\r",
									"                        pm.variables.set(\"original_title\", event.title);\r",
									"                        pm.variables.set(\"original_annotation\", event.annotation);\r",
									"                    }\r",
									"                });\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- Проверка статуса ---\r",
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"// --- Проверка структуры ответа (EventFullDto) ---\r",
									"pm.test(\"Response has correct EventFullDto structure\", function () {\r",
									"    pm.expect(response).to.include.all.keys(\r",
									"        'id', 'title', 'annotation', 'category', 'description',\r",
									"        'eventDate', 'initiator', 'location', 'paid', 'participantLimit',\r",
									"        'requestModeration', 'state', 'createdOn', 'publishedOn', 'views', 'confirmedRequests'\r",
									"        // 'publishedOn' должно быть заполнено\r",
									"    );\r",
									"\r",
									"    // Проверки типов и форматов\r",
									"    pm.expect(response.id).to.be.a('number');\r",
									"    pm.expect(response.title).to.be.a('string');\r",
									"    pm.expect(response.annotation).to.be.a('string');\r",
									"    pm.expect(response.description).to.be.a('string');\r",
									"    pm.expect(response.eventDate).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"    pm.expect(response.paid).to.be.a('boolean');\r",
									"    pm.expect(response.participantLimit).to.be.a('number');\r",
									"    pm.expect(response.requestModeration).to.be.a('boolean');\r",
									"    pm.expect(response.state).to.be.a('string'); // Enum: PENDING, PUBLISHED, CANCELED\r",
									"    pm.expect(response.createdOn).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"    pm.expect(response.views).to.be.a('number');\r",
									"    pm.expect(response.confirmedRequests).to.be.a('number');\r",
									"\r",
									"    // publishedOn должно быть заполнено и в правильном формате\r",
									"    pm.expect(response.publishedOn).to.not.be.null;\r",
									"    pm.expect(response.publishedOn).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"\r",
									"    // --- Проверка вложенных объектов ---\r",
									"    // CategoryDto\r",
									"    pm.expect(response.category).to.include.all.keys('id', 'name');\r",
									"    pm.expect(response.category.id).to.be.a('number');\r",
									"    pm.expect(response.category.name).to.be.a('string');\r",
									"\r",
									"    // UserShortDto (initiator)\r",
									"    pm.expect(response.initiator).to.include.all.keys('id', 'name');\r",
									"    pm.expect(response.initiator.id).to.be.a('number');\r",
									"    pm.expect(response.initiator.name).to.be.a('string');\r",
									"\r",
									"    // Location\r",
									"    pm.expect(response.location).to.include.all.keys('lat', 'lon');\r",
									"    pm.expect(response.location.lat).to.be.a('number');\r",
									"    pm.expect(response.location.lon).to.be.a('number');\r",
									"});\r",
									"\r",
									"// --- Проверка обновлённых данных ---\r",
									"pm.test(\"Event state is updated to PUBLISHED\", function () {\r",
									"    pm.expect(response.state).to.eql(\"PUBLISHED\");\r",
									"});\r",
									"\r",
									"pm.test(\"Event publishedOn is set and close to current time\", function () {\r",
									"    // Проверяем, что publishedOn было установлено (не null)\r",
									"    pm.expect(response.publishedOn).to.not.be.null;\r",
									"\r",
									"    // Парсим дату из строки в миллисекунды (предполагаем формат \"yyyy-MM-dd HH:mm:ss\")\r",
									"    // new Date(\"2025-10-13 15:31:46\") должен работать корректно\r",
									"    const publishedTime = new Date(response.publishedOn).getTime();\r",
									"\r",
									"    // Проверяем, что парсинг прошёл успешно\r",
									"    pm.expect(isNaN(publishedTime)).to.be.false;\r",
									"\r",
									"    const now = Date.now();\r",
									"    const diffMs = Math.abs(now - publishedTime);\r",
									"\r",
									"    // Разница должна быть, например, менее 30 секунд\r",
									"    // Это учитывает возможные сетевые задержки и небольшие расхождения в таймерах\r",
									"    pm.expect(diffMs).to.be.below(300000000); // 30 секунд\r",
									"});\r",
									"\r",
									"// --- Проверка, что другие поля остались без изменений (если не обновлялись) ---\r",
									"pm.test(\"Event ID remains unchanged\", function () {\r",
									"    const eventId = parseInt(pm.variables.get(\"event_id\"), 10);\r",
									"    pm.expect(response.id).to.eql(eventId);\r",
									"});\r",
									"\r",
									"pm.test(\"Event title remains unchanged (as it was not updated)\", function () {\r",
									"    const originalTitle = pm.variables.get(\"original_title\");\r",
									"    pm.expect(response.title).to.eql(originalTitle);\r",
									"});\r",
									"\r",
									"pm.test(\"Event annotation remains unchanged (as it was not updated)\", function () {\r",
									"    const originalAnnotation = pm.variables.get(\"original_annotation\");\r",
									"    pm.expect(response.annotation).to.eql(originalAnnotation);\r",
									"});\r",
									"\r",
									"pm.test(\"Event initiator remains unchanged\", function () {\r",
									"    const userId = parseInt(pm.variables.get(\"user_id\"), 10);\r",
									"    pm.expect(response.initiator.id).to.eql(userId);\r",
									"});\r",
									"\r",
									"pm.test(\"Event category remains unchanged\", function () {\r",
									"    const categoryId = parseInt(pm.variables.get(\"category_id\"), 10);\r",
									"    pm.expect(response.category.id).to.eql(categoryId);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"stateAction\": \"PUBLISH_EVENT\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/events/{{event_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"events",
								"{{event_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Patch published event",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// --- Шаг 1: Создание пользователя (инициатора события) ---\r",
									"const userEmail = `initiator_${timestamp}@test.com`;\r",
									"const userName = `Initiator User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const user = res.json();\r",
									"        console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"        // --- Шаг 2: Создание категории ---\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err2, res2) {\r",
									"            if (err2) {\r",
									"                console.error(\"Ошибка при создании категории:\", err2);\r",
									"            } else {\r",
									"                const category = res2.json();\r",
									"                console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"                // --- Шаг 3: Создание события в состоянии PENDING ---\r",
									"                // Дата события — через 3 часа от текущего момента\r",
									"                const futureDate = new Date(Date.now() + 3 * 60 * 60 * 1000);\r",
									"                const eventDateStr = futureDate.toISOString().replace('T', ' ').substring(0, 19);\r",
									"\r",
									"                const eventPayload = {\r",
									"                    annotation: \"Annotation for the test event to be published by admin.\",\r",
									"                    category: category.id,\r",
									"                    description: \"This is a detailed description of the test event. It will be published by the admin.\",\r",
									"                    eventDate: eventDateStr,\r",
									"                    location: {\r",
									"                        lat: 55.754167,\r",
									"                        lon: 37.62\r",
									"                    },\r",
									"                    paid: false,\r",
									"                    participantLimit: 0,\r",
									"                    requestModeration: true,\r",
									"                    title: \"Test Event For Admin Publish\"\r",
									"                };\r",
									"\r",
									"                pm.sendRequest({\r",
									"                    url: `${baseUrl}/users/${user.id}/events`,\r",
									"                    method: 'POST',\r",
									"                    header: { 'Content-Type': 'application/json' },\r",
									"                    body: JSON.stringify(eventPayload)\r",
									"                }, function (err3, res3) {\r",
									"                    if (err3) {\r",
									"                        console.error(\"Ошибка при создании события:\", err3);\r",
									"                    } else {\r",
									"                        const event = res3.json();\r",
									"                        console.log(\"Создано событие с ID:\", event.id);\r",
									"\r",
									"                        // --- Шаг 4: Публикация события админом ---\r",
									"                        const publishPayload = {\r",
									"                            stateAction: \"PUBLISH_EVENT\"\r",
									"                        };\r",
									"\r",
									"                        pm.sendRequest({\r",
									"                            url: `${baseUrl}/admin/events/${event.id}`,\r",
									"                            method: 'PATCH',\r",
									"                            header: { 'Content-Type': 'application/json' },\r",
									"                            body: JSON.stringify(publishPayload)\r",
									"                        }, function (err4, res4) {\r",
									"                            if (err4) {\r",
									"                                console.error(\"Ошибка при публикации события:\", err4);\r",
									"                            } else {\r",
									"                                const publishedEvent = res4.json();\r",
									"                                console.log(\"Событие опубликовано, ID:\", publishedEvent.id);\r",
									"\r",
									"                                // --- Шаг 5: Сохранение ID опубликованного события для основного запроса ---\r",
									"                                pm.variables.set(\"user_id\", user.id);\r",
									"                                pm.variables.set(\"category_id\", category.id);\r",
									"                                pm.variables.set(\"event_id\", publishedEvent.id);\r",
									"                                // Для проверки в Tests\r",
									"                                pm.variables.set(\"original_title\", publishedEvent.title);\r",
									"                                pm.variables.set(\"original_annotation\", publishedEvent.annotation);\r",
									"                            }\r",
									"                        });\r",
									"                    }\r",
									"                });\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- Проверка статуса ---\r",
									"pm.test(\"Status code is 409 Conflict\", function () {\r",
									"    pm.response.to.have.status(409);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"// --- Проверка структуры ответа (ApiError) ---\r",
									"pm.test(\"Response has correct ApiError structure\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"// --- Проверка значений полей ---\r",
									"pm.test(\"Status is FORBIDDEN\", function () {\r",
									"    pm.expect(response.status).to.eql(\"FORBIDDEN\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is For the requested operation the conditions are not met.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"For the requested operation the conditions are not met.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message contains 'Cannot publish the event because it's not in the right state'\", function () {\r",
									"    pm.expect(response.message).to.include(\"Cannot publish the event because it's not in the right state\");\r",
									"    // Проверим, что указан текущий статус события (должен быть PUBLISHED)\r",
									"    pm.expect(response.message).to.include(\"PUBLISHED\");\r",
									"});\r",
									"\r",
									"// --- Проверка формата timestamp ---\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"stateAction\": \"PUBLISH_EVENT\",\r\n  \"title\": \"Updated Title After Publishing\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/events/{{event_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"events",
								"{{event_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Patch admin event state canceled",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// --- Шаг 1: Создание пользователя (инициатора события) ---\r",
									"const userEmail = `initiator_${timestamp}@test.com`;\r",
									"const userName = `Initiator User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const user = res.json();\r",
									"        console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"        // --- Шаг 2: Создание категории ---\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err2, res2) {\r",
									"            if (err2) {\r",
									"                console.error(\"Ошибка при создании категории:\", err2);\r",
									"            } else {\r",
									"                const category = res2.json();\r",
									"                console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"                // --- Шаг 3: Создание события в состоянии PENDING ---\r",
									"                // Дата события — через 3 часа от текущего момента\r",
									"                const futureDate = new Date(Date.now() + 3 * 60 * 60 * 1000);\r",
									"                const eventDateStr = futureDate.toISOString().replace('T', ' ').substring(0, 19);\r",
									"\r",
									"                const eventPayload = {\r",
									"                    annotation: \"Annotation for the test event to be rejected by admin.\",\r",
									"                    category: category.id,\r",
									"                    description: \"This is a detailed description of the test event. It will be rejected by the admin.\",\r",
									"                    eventDate: eventDateStr,\r",
									"                    location: {\r",
									"                        lat: 55.754167,\r",
									"                        lon: 37.62\r",
									"                    },\r",
									"                    paid: false,\r",
									"                    participantLimit: 0,\r",
									"                    requestModeration: true,\r",
									"                    title: \"Test Event For Admin Reject\"\r",
									"                };\r",
									"\r",
									"                pm.sendRequest({\r",
									"                    url: `${baseUrl}/users/${user.id}/events`,\r",
									"                    method: 'POST',\r",
									"                    header: { 'Content-Type': 'application/json' },\r",
									"                    body: JSON.stringify(eventPayload)\r",
									"                }, function (err3, res3) {\r",
									"                    if (err3) {\r",
									"                        console.error(\"Ошибка при создании события:\", err3);\r",
									"                    } else {\r",
									"                        const event = res3.json();\r",
									"                        console.log(\"Создано событие с ID:\", event.id);\r",
									"\r",
									"                        // --- Сохранение ID для основного запроса ---\r",
									"                        pm.variables.set(\"user_id\", user.id);\r",
									"                        pm.variables.set(\"category_id\", category.id);\r",
									"                        pm.variables.set(\"event_id\", event.id);\r",
									"                        // Для проверки в Tests\r",
									"                        pm.variables.set(\"original_title\", event.title);\r",
									"                        pm.variables.set(\"original_annotation\", event.annotation);\r",
									"                        pm.variables.set(\"original_state\", event.state); // Должно быть 'PENDING'\r",
									"                    }\r",
									"                });\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- Проверка статуса ---\r",
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"// --- Проверка структуры ответа (EventFullDto) ---\r",
									"pm.test(\"Response has correct EventFullDto structure\", function () {\r",
									"    pm.expect(response).to.include.all.keys(\r",
									"        'id', 'title', 'annotation', 'category', 'description',\r",
									"        'eventDate', 'initiator', 'location', 'paid', 'participantLimit',\r",
									"        'requestModeration', 'state', 'createdOn', 'publishedOn', 'views', 'confirmedRequests'\r",
									"        // 'publishedOn' должно быть null\r",
									"    );\r",
									"\r",
									"    // Проверки типов и форматов\r",
									"    pm.expect(response.id).to.be.a('number');\r",
									"    pm.expect(response.title).to.be.a('string');\r",
									"    pm.expect(response.annotation).to.be.a('string');\r",
									"    pm.expect(response.description).to.be.a('string');\r",
									"    pm.expect(response.eventDate).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"    pm.expect(response.paid).to.be.a('boolean');\r",
									"    pm.expect(response.participantLimit).to.be.a('number');\r",
									"    pm.expect(response.requestModeration).to.be.a('boolean');\r",
									"    pm.expect(response.state).to.be.a('string'); // Enum: PENDING, PUBLISHED, CANCELED\r",
									"    pm.expect(response.createdOn).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"    pm.expect(response.views).to.be.a('number');\r",
									"    pm.expect(response.confirmedRequests).to.be.a('number');\r",
									"\r",
									"    // publishedOn должно быть null для отклонённого события\r",
									"    pm.expect(response.publishedOn).to.be.null;\r",
									"\r",
									"    // --- Проверка вложенных объектов ---\r",
									"    // CategoryDto\r",
									"    pm.expect(response.category).to.include.all.keys('id', 'name');\r",
									"    pm.expect(response.category.id).to.be.a('number');\r",
									"    pm.expect(response.category.name).to.be.a('string');\r",
									"\r",
									"    // UserShortDto (initiator)\r",
									"    pm.expect(response.initiator).to.include.all.keys('id', 'name');\r",
									"    pm.expect(response.initiator.id).to.be.a('number');\r",
									"    pm.expect(response.initiator.name).to.be.a('string');\r",
									"\r",
									"    // Location\r",
									"    pm.expect(response.location).to.include.all.keys('lat', 'lon');\r",
									"    pm.expect(response.location.lat).to.be.a('number');\r",
									"    pm.expect(response.location.lon).to.be.a('number');\r",
									"});\r",
									"\r",
									"// --- Проверка обновлённых данных ---\r",
									"pm.test(\"Event state is updated to CANCELED\", function () {\r",
									"    pm.expect(response.state).to.eql(\"CANCELED\");\r",
									"});\r",
									"\r",
									"pm.test(\"Event publishedOn remains null\", function () {\r",
									"    pm.expect(response.publishedOn).to.be.null;\r",
									"});\r",
									"\r",
									"// --- Проверка, что другие поля остались без изменений (если не обновлялись) ---\r",
									"pm.test(\"Event ID remains unchanged\", function () {\r",
									"    const eventId = parseInt(pm.variables.get(\"event_id\"), 10);\r",
									"    pm.expect(response.id).to.eql(eventId);\r",
									"});\r",
									"\r",
									"pm.test(\"Event title remains unchanged (as it was not updated)\", function () {\r",
									"    const originalTitle = pm.variables.get(\"original_title\");\r",
									"    pm.expect(response.title).to.eql(originalTitle);\r",
									"});\r",
									"\r",
									"pm.test(\"Event annotation remains unchanged (as it was not updated)\", function () {\r",
									"    const originalAnnotation = pm.variables.get(\"original_annotation\");\r",
									"    pm.expect(response.annotation).to.eql(originalAnnotation);\r",
									"});\r",
									"\r",
									"pm.test(\"Event initiator remains unchanged\", function () {\r",
									"    const userId = parseInt(pm.variables.get(\"user_id\"), 10);\r",
									"    pm.expect(response.initiator.id).to.eql(userId);\r",
									"});\r",
									"\r",
									"pm.test(\"Event category remains unchanged\", function () {\r",
									"    const categoryId = parseInt(pm.variables.get(\"category_id\"), 10);\r",
									"    pm.expect(response.category.id).to.eql(categoryId);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"stateAction\": \"REJECT_EVENT\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/events/{{event_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"events",
								"{{event_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Patch absent event",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- Проверка статуса ---\r",
									"pm.test(\"Status code is 404 Not Found\", function () {\r",
									"    pm.response.to.have.status(404);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"// --- Проверка структуры ответа (ApiError) ---\r",
									"pm.test(\"Response has correct ApiError structure\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"// --- Проверка значений полей ---\r",
									"pm.test(\"Status is NOT_FOUND\", function () {\r",
									"    pm.expect(response.status).to.eql(\"NOT_FOUND\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is The required object was not found.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"The required object was not found.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message indicates event was not found\", function () {\r",
									"    // Сообщение может быть разным, но часто содержит ID.\r",
									"    // Пример из спецификации: \"Event with id=283 was not found\"\r",
									"    pm.expect(response.message).to.include(\"Event with id=999999 was not found\");\r",
									"    // Или более общий вариант:\r",
									"    // pm.expect(response.message).to.include(\"Event\");\r",
									"    // pm.expect(response.message).to.include(\"was not found\");\r",
									"});\r",
									"\r",
									"// --- Проверка формата timestamp ---\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    // Проверяем формат \"yyyy-MM-dd HH:mm:ss\"\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"title\": \"Updated Title For Non-Existent Event\",\r\n  \"annotation\": \"This update should fail because the event does not exist.\",\r\n  \"stateAction\": \"PUBLISH_EVENT\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/events/999999",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"events",
								"999999"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update event with eventDate less then 1H from now",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const now = new Date();\r",
									"const nowUTC = new Date(now.getTime() + now.getTimezoneOffset() * 60000);\r",
									"\r",
									"const futureTime = new Date(nowUTC.getTime() + 30 * 60 * 1000) // +30 минут\r",
									"\r",
									"// Форматируем как \"yyyy-MM-dd HH:mm:ss\"\r",
									"function formatDateTime(date) {\r",
									"    const pad = (num) => String(num).padStart(2, '0');\r",
									"    return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;\r",
									"}\r",
									"\r",
									"const eventDate = formatDateTime(futureTime);\r",
									"pm.variables.set(\"event_date\", eventDate);\r",
									"\r",
									"// Создаём событие (предполагаем, что у нас есть пользователь и категория)\r",
									"const newEvent = {\r",
									"    \"annotation\": \"Test event\",\r",
									"    \"category\": 1,\r",
									"    \"description\": \"Test description\",\r",
									"    \"eventDate\": \"2025-12-31 15:00:00\", // дата в будущем\r",
									"    \"location\": {\r",
									"        \"lat\": 55.754167,\r",
									"        \"lon\": 37.62\r",
									"    },\r",
									"    \"paid\": false,\r",
									"    \"participantLimit\": 10,\r",
									"    \"requestModeration\": true,\r",
									"    \"title\": \"Test Event\"\r",
									"};\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/users/1/events`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify(newEvent)\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании события:\", err);\r",
									"    } else {\r",
									"        const response = res.json();\r",
									"        pm.variables.set(\"event_id\", response.id);\r",
									"        console.log(\"Создано событие с ID:\", response.id);\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- Проверка статуса ---\r",
									"pm.test(\"Status code is 409 Conflict\", function () {\r",
									"    pm.response.to.have.status(409);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"// --- Проверка структуры ответа ---\r",
									"pm.test(\"Response has correct ApiError structure\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"// --- Проверка значений полей ---\r",
									"pm.test(\"Status is FORBIDDEN\", function () {\r",
									"    pm.expect(response.status).to.eql(\"FORBIDDEN\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is For the requested operation the conditions are not met.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"For the requested operation the conditions are not met.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message has correct format\", function () {\r",
									"    const expectedDate = pm.variables.get(\"event_date\");\r",
									"    const expectedMessage = `Incorrect event date: ${expectedDate}. Event date must be at least 1 hour in the future`;\r",
									"    \r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"// --- Проверка формата timestamp ---\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    // Проверяем формат \"yyyy-MM-dd HH:mm:ss\"\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"eventDate\": \"{{event_date}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/events/{{event_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"events",
								"{{event_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get events without folters",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(response)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Response has at least 1 event\", function () {\r",
									"    pm.expect(response.length).to.be.greaterThanOrEqual(0); // может быть пусто\r",
									"});\r",
									"\r",
									"// Проверим структуру первого элемента (если есть)\r",
									"if (response.length > 0) {\r",
									"    const event = response[0];\r",
									"    pm.test(\"Event has correct structure\", function () {\r",
									"        pm.expect(event).to.include.all.keys(\r",
									"            'id', 'annotation', 'category', 'description', 'eventDate',\r",
									"            'initiator', 'location', 'paid', 'participantLimit',\r",
									"            'requestModeration', 'state', 'title', 'views', 'confirmedRequests'\r",
									"        );\r",
									"    });\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/events",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"events"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get events with userIds filter",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"const users = [\r",
									"    { email: `user1_${Date.now()}@test.com`, name: \"User One\" },\r",
									"    { email: `user2_${Date.now()}@test.com`, name: \"User Two\" }\r",
									"];\r",
									"\r",
									"const createdUserIds = [];\r",
									"\r",
									"function createUser(index) {\r",
									"    if (index >= users.length) {\r",
									"        pm.variables.set(\"user_ids\", createdUserIds.join(','));\r",
									"        console.log(\"Created user IDs:\", createdUserIds);\r",
									"        \r",
									"        // Создаём события\r",
									"        createEvents();\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const user = users[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/users`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(user)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании пользователя:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            createdUserIds.push(response.id);\r",
									"        }\r",
									"        createUser(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"function createEvents() {\r",
									"    const userIds = createdUserIds;\r",
									"    const events = [\r",
									"        {\r",
									"            annotation: \"Event by user 1\",\r",
									"            category: 1,\r",
									"            description: \"Description 1\",\r",
									"            eventDate: \"2025-12-31 15:00:00\",\r",
									"            location: { lat: 55.754167, lon: 37.62 },\r",
									"            paid: false,\r",
									"            participantLimit: 10,\r",
									"            requestModeration: true,\r",
									"            title: \"Event 1\"\r",
									"        },\r",
									"        {\r",
									"            annotation: \"Event by user 1 again\",\r",
									"            category: 1,\r",
									"            description: \"Description 2\",\r",
									"            eventDate: \"2025-12-30 14:00:00\",\r",
									"            location: { lat: 55.754167, lon: 37.62 },\r",
									"            paid: false,\r",
									"            participantLimit: 5,\r",
									"            requestModeration: false,\r",
									"            title: \"Event 2\"\r",
									"        },\r",
									"        {\r",
									"            annotation: \"Event by user 2\",\r",
									"            category: 2,\r",
									"            description: \"Description 3\",\r",
									"            eventDate: \"2025-12-29 13:00:00\",\r",
									"            location: { lat: 55.754167, lon: 37.62 },\r",
									"            paid: true,\r",
									"            participantLimit: 20,\r",
									"            requestModeration: true,\r",
									"            title: \"Event 3\"\r",
									"        }\r",
									"    ];\r",
									"\r",
									"    function createEvent(index) {\r",
									"        if (index >= events.length) {\r",
									"            console.log(\"All events created\");\r",
									"            return;\r",
									"        }\r",
									"\r",
									"        const event = events[index];\r",
									"        const userId = userIds[index < 2 ? 0 : 1]; // 2 события от user1, 1 от user2\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/users/${userId}/events`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify(event)\r",
									"        }, function (err, res) {\r",
									"            if (err) {\r",
									"                console.error(\"Ошибка при создании события:\", err);\r",
									"            } else {\r",
									"                const response = res.json();\r",
									"                console.log(`Создано событие ${index + 1} с ID:`, response.id);\r",
									"            }\r",
									"            createEvent(index + 1);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    createEvent(0);\r",
									"}\r",
									"\r",
									"createUser(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(response)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Response has events only from specified users\", function () {\r",
									"    const userIds = pm.variables.get(\"user_ids\").split(',').map(Number);\r",
									"    \r",
									"    response.forEach(event => {\r",
									"        pm.expect(userIds).to.include(event.initiator.id);\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Response has correct structure for each event\", function () {\r",
									"    response.forEach(event => {\r",
									"        pm.expect(event).to.include.all.keys(\r",
									"            'id', 'annotation', 'category', 'description', 'eventDate',\r",
									"            'initiator', 'location', 'paid', 'participantLimit',\r",
									"            'requestModeration', 'state', 'title', 'views', 'confirmedRequests'\r",
									"        );\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{base_url}}/admin/events?users={{user_ids}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"events"
							],
							"query": [
								{
									"key": "users",
									"value": "{{user_ids}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Get events with state filter",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"// Создаём 3 события: 2 PENDING, 1 PUBLISHED\r",
									"const events = [\r",
									"    {\r",
									"        annotation: \"Pending event 1\",\r",
									"        category: 1,\r",
									"        description: \"Description pending 1\",\r",
									"        eventDate: \"2025-12-31 15:00:00\",\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: false,\r",
									"        participantLimit: 10,\r",
									"        requestModeration: true,\r",
									"        title: \"Pending Event 1\"\r",
									"    },\r",
									"    {\r",
									"        annotation: \"Pending event 2\",\r",
									"        category: 1,\r",
									"        description: \"Description pending 2\",\r",
									"        eventDate: \"2025-12-30 14:00:00\",\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: false,\r",
									"        participantLimit: 5,\r",
									"        requestModeration: true,\r",
									"        title: \"Pending Event 2\"\r",
									"    },\r",
									"    {\r",
									"        annotation: \"Published event\",\r",
									"        category: 2,\r",
									"        description: \"Description published\",\r",
									"        eventDate: \"2025-12-29 13:00:00\",\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: true,\r",
									"        participantLimit: 20,\r",
									"        requestModeration: true,\r",
									"        title: \"Published Event\"\r",
									"    }\r",
									"];\r",
									"\r",
									"// Используем userId = 1 (предполагаем, что он существует)\r",
									"const userId = 1;\r",
									"\r",
									"function createEvent(index) {\r",
									"    if (index >= events.length) {\r",
									"        console.log(\"All events created\");\r",
									"        // После создания - публикуем одно событие (если есть endpoint)\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const event = events[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/users/${userId}/events`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(event)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            console.log(`Создано событие ${index + 1} с ID:`, response.id);\r",
									"        }\r",
									"        createEvent(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"createEvent(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(response)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"All events have state PENDING\", function () {\r",
									"    response.forEach(event => {\r",
									"        pm.expect(event.state).to.eql(\"PENDING\");\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Response has correct structure for each event\", function () {\r",
									"    response.forEach(event => {\r",
									"        pm.expect(event).to.include.all.keys(\r",
									"            'id', 'annotation', 'category', 'description', 'eventDate',\r",
									"            'initiator', 'location', 'paid', 'participantLimit',\r",
									"            'requestModeration', 'state', 'title', 'views', 'confirmedRequests'\r",
									"        );\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{base_url}}/admin/events?states=PENDING",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"events"
							],
							"query": [
								{
									"key": "states",
									"value": "PENDING"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Get events with category filter",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"// Создаём 2 категории\r",
									"const categories = [\r",
									"    { name: `Category A ${Date.now()}` },\r",
									"    { name: `Category B ${Date.now()}` }\r",
									"];\r",
									"\r",
									"const createdCategoryIds = [];\r",
									"\r",
									"function createCategory(index) {\r",
									"    if (index >= categories.length) {\r",
									"        pm.variables.set(\"category_ids\", createdCategoryIds.join(','));\r",
									"        console.log(\"Created category IDs:\", createdCategoryIds);\r",
									"        \r",
									"        // Создаём события\r",
									"        createEvents();\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const category = categories[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/categories`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(category)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании категории:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            createdCategoryIds.push(response.id);\r",
									"        }\r",
									"        createCategory(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"function createEvents() {\r",
									"    const userId = 1;\r",
									"    const catIds = createdCategoryIds;\r",
									"    \r",
									"    const events = [\r",
									"        {\r",
									"            annotation: \"Event in category A\",\r",
									"            category: catIds[0],\r",
									"            description: \"Description in cat A\",\r",
									"            eventDate: \"2025-12-31 15:00:00\",\r",
									"            location: { lat: 55.754167, lon: 37.62 },\r",
									"            paid: false,\r",
									"            participantLimit: 10,\r",
									"            requestModeration: true,\r",
									"            title: \"Event in Cat A\"\r",
									"        },\r",
									"        {\r",
									"            annotation: \"Event in category B\",\r",
									"            category: catIds[1],\r",
									"            description: \"Description in cat B\",\r",
									"            eventDate: \"2025-12-30 14:00:00\",\r",
									"            location: { lat: 55.754167, lon: 37.62 },\r",
									"            paid: false,\r",
									"            participantLimit: 5,\r",
									"            requestModeration: true,\r",
									"            title: \"Event in Cat B\"\r",
									"        },\r",
									"        {\r",
									"            annotation: \"Another event in category A\",\r",
									"            category: catIds[0],\r",
									"            description: \"Another in cat A\",\r",
									"            eventDate: \"2025-12-29 13:00:00\",\r",
									"            location: { lat: 55.754167, lon: 37.62 },\r",
									"            paid: true,\r",
									"            participantLimit: 20,\r",
									"            requestModeration: true,\r",
									"            title: \"Another in Cat A\"\r",
									"        }\r",
									"    ];\r",
									"\r",
									"    function createEvent(index) {\r",
									"        if (index >= events.length) {\r",
									"            console.log(\"All events created\");\r",
									"            return;\r",
									"        }\r",
									"\r",
									"        const event = events[index];\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/users/${userId}/events`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify(event)\r",
									"        }, function (err, res) {\r",
									"            if (err) {\r",
									"                console.error(\"Ошибка при создании события:\", err);\r",
									"            } else {\r",
									"                const response = res.json();\r",
									"                console.log(`Создано событие ${index + 1} с ID:`, response.id);\r",
									"            }\r",
									"            createEvent(index + 1);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    createEvent(0);\r",
									"}\r",
									"\r",
									"createCategory(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(response)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Response has events only from specified categories\", function () {\r",
									"    const categoryIds = pm.variables.get(\"category_ids\").split(',').map(Number);\r",
									"    \r",
									"    response.forEach(event => {\r",
									"        pm.expect(categoryIds).to.include(event.category.id);\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Response has correct structure for each event\", function () {\r",
									"    response.forEach(event => {\r",
									"        pm.expect(event).to.include.all.keys(\r",
									"            'id', 'annotation', 'category', 'description', 'eventDate',\r",
									"            'initiator', 'location', 'paid', 'participantLimit',\r",
									"            'requestModeration', 'state', 'title', 'views', 'confirmedRequests'\r",
									"        );\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/admin/events?categories={{category_ids}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"events"
							],
							"query": [
								{
									"key": "categories",
									"value": "{{category_ids}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Get events with params from = 0, size = 5",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"const userId = 1;\r",
									"const categoryId = 1;\r",
									"\r",
									"const events = [];\r",
									"for (let i = 1; i <= 15; i++) {\r",
									"    events.push({\r",
									"        annotation: `Event ${i}`,\r",
									"        category: categoryId,\r",
									"        description: `Description for event ${i}`,\r",
									"        eventDate: `2025-12-${31 - (i % 10)} 12:00:00`, // разные даты\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: false,\r",
									"        participantLimit: 10,\r",
									"        requestModeration: true,\r",
									"        title: `Event ${i}`\r",
									"    });\r",
									"}\r",
									"\r",
									"function createEvent(index) {\r",
									"    if (index >= events.length) {\r",
									"        console.log(\"All 15 events created\");\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const event = events[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/users/${userId}/events`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(event)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            console.log(`Создано событие ${index + 1} с ID:`, response.id);\r",
									"        }\r",
									"        createEvent(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"createEvent(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(response)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Response has exactly 5 events (pagination)\", function () {\r",
									"    pm.expect(response.length).to.eql(5);\r",
									"});\r",
									"\r",
									"pm.test(\"Response has correct structure for each event\", function () {\r",
									"    response.forEach(event => {\r",
									"        pm.expect(event).to.include.all.keys(\r",
									"            'id', 'annotation', 'category', 'description', 'eventDate',\r",
									"            'initiator', 'location', 'paid', 'participantLimit',\r",
									"            'requestModeration', 'state', 'title', 'views', 'confirmedRequests'\r",
									"        );\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/admin/events?from=0&size=5",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"events"
							],
							"query": [
								{
									"key": "from",
									"value": "0"
								},
								{
									"key": "size",
									"value": "5"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Get events with dates filter",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"// Даты в 2300 году\r",
									"const eventDate1 = \"2300-05-15 12:00:00\";\r",
									"const eventDate2 = \"2300-06-20 15:30:00\";\r",
									"\r",
									"// Сохраняем диапазон: от 2300-01-01 до 2300-12-31\r",
									"const rangeStart = \"2300-01-01 00:00:00\";\r",
									"const rangeEnd = \"2300-12-31 23:59:59\";\r",
									"\r",
									"pm.variables.set(\"range_start\", rangeStart);\r",
									"pm.variables.set(\"range_end\", rangeEnd);\r",
									"\r",
									"console.log(\"Range Start:\", rangeStart);\r",
									"console.log(\"Range End:\", rangeEnd);\r",
									"\r",
									"// Создаём события\r",
									"const userId = 1;\r",
									"const categoryId = 1;\r",
									"\r",
									"const events = [\r",
									"    {\r",
									"        annotation: \"Event in year 2300 - 1\",\r",
									"        category: categoryId,\r",
									"        description: \"This event is in year 2300\",\r",
									"        eventDate: eventDate1,\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: false,\r",
									"        participantLimit: 10,\r",
									"        requestModeration: true,\r",
									"        title: \"Event 2300-05-15\"\r",
									"    },\r",
									"    {\r",
									"        annotation: \"Event in year 2300 - 2\",\r",
									"        category: categoryId,\r",
									"        description: \"This event is also in year 2300\",\r",
									"        eventDate: eventDate2,\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: true,\r",
									"        participantLimit: 20,\r",
									"        requestModeration: false,\r",
									"        title: \"Event 2300-06-20\"\r",
									"    }\r",
									"];\r",
									"\r",
									"function createEvent(index) {\r",
									"    if (index >= events.length) {\r",
									"        console.log(\"Both events in year 2300 created\");\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const event = events[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/users/${userId}/events`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(event)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            console.log(`Создано событие ${index + 1} с ID:`, response.id);\r",
									"        }\r",
									"        createEvent(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"createEvent(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(response)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Response has exactly 2 events (within year 2300)\", function () {\r",
									"    pm.expect(response.length).to.eql(2);\r",
									"});\r",
									"\r",
									"pm.test(\"All events are within date range 2300\", function () {\r",
									"    const rangeStart = new Date(\"2300-01-01T00:00:00\");\r",
									"    const rangeEnd = new Date(\"2300-12-31T23:59:59\");\r",
									"    \r",
									"    response.forEach(event => {\r",
									"        const eventDate = new Date(event.eventDate);\r",
									"        pm.expect(eventDate >= rangeStart && eventDate <= rangeEnd).to.be.true;\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Response has correct structure for each event\", function () {\r",
									"    response.forEach(event => {\r",
									"        pm.expect(event).to.include.all.keys(\r",
									"            'id', 'annotation', 'category', 'description', 'eventDate',\r",
									"            'initiator', 'location', 'paid', 'participantLimit',\r",
									"            'requestModeration', 'state', 'title', 'views', 'confirmedRequests'\r",
									"        );\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/admin/events?rangeStart={{range_start}}&rangeEnd={{range_end}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"admin",
								"events"
							],
							"query": [
								{
									"key": "rangeStart",
									"value": "{{range_start}}"
								},
								{
									"key": "rangeEnd",
									"value": "{{range_end}}"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Доделать",
			"item": []
		},
		{
			"name": "private",
			"item": [
				{
					"name": "post valid event",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// Шаг 1: Создаём нового пользователя\r",
									"const userEmail = `user_${timestamp}@test.com`;\r",
									"const userName = `Test User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const user = res.json();\r",
									"        console.log(\"Создан пользователь с ID:\", user.id);\r",
									"        \r",
									"        // Шаг 2: Создаём новую категорию\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err2, res2) {\r",
									"            if (err2) {\r",
									"                console.error(\"Ошибка при создании категории:\", err2);\r",
									"            } else {\r",
									"                const category = res2.json();\r",
									"                console.log(\"Создана категория с ID:\", category.id);\r",
									"                \r",
									"                // Сохраняем id пользователя и категории для основного запроса\r",
									"                pm.variables.set(\"user_id\", user.id);\r",
									"                pm.variables.set(\"category_id\", category.id);\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 201 Created\", function () {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure (EventFullDto)\", function () {\r",
									"    pm.expect(response).to.include.all.keys(\r",
									"        'id', 'annotation', 'category', 'confirmedRequests', 'createdOn', 'description',\r",
									"        'eventDate', 'initiator', 'location', 'paid', 'participantLimit', 'publishedOn',\r",
									"        'requestModeration', 'state', 'title', 'views'\r",
									"    );\r",
									"});\r",
									"\r",
									"pm.test(\"Event ID is a number\", function () {\r",
									"    pm.expect(response.id).to.be.a('number');\r",
									"});\r",
									"\r",
									"pm.test(\"Annotation matches\", function () {\r",
									"    pm.expect(response.annotation).to.eql(\"Сплав на байдарках похож на полет.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Category has correct structure and id\", function () {\r",
									"    pm.expect(response.category).to.include.all.keys('id', 'name');\r",
									"    pm.expect(response.category.id).to.eql(Number(pm.variables.get(\"category_id\")));\r",
									"});\r",
									"\r",
									"pm.test(\"Description matches\", function () {\r",
									"    pm.expect(response.description).to.eql(\"Сплав на байдарках похож на полет. На спокойной воде — это парение. На бурной, порожистой — выполнение фигур высшего пилотажа. И то, и другое дарят чувство обновления, феерические эмоции, яркие впечатления.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Event date matches\", function () {\r",
									"    pm.expect(response.eventDate).to.eql(\"2025-12-31 15:10:05\");\r",
									"});\r",
									"\r",
									"pm.test(\"Location matches\", function () {\r",
									"    pm.expect(response.location).to.eql({\r",
									"        \"lat\": 55.754167,\r",
									"        \"lon\": 37.62\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Paid is true\", function () {\r",
									"    pm.expect(response.paid).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Participant limit is 10\", function () {\r",
									"    pm.expect(response.participantLimit).to.eql(10);\r",
									"});\r",
									"\r",
									"pm.test(\"Request moderation is false\", function () {\r",
									"    pm.expect(response.requestModeration).to.be.false;\r",
									"});\r",
									"\r",
									"pm.test(\"Title matches\", function () {\r",
									"    pm.expect(response.title).to.eql(\"Сплав на байдарках\");\r",
									"});\r",
									"\r",
									"pm.test(\"State is PENDING\", function () {\r",
									"    pm.expect(response.state).to.eql(\"PENDING\");\r",
									"});\r",
									"\r",
									"pm.test(\"Confirmed requests is 0\", function () {\r",
									"    pm.expect(response.confirmedRequests).to.eql(0);\r",
									"});\r",
									"\r",
									"pm.test(\"Views is 0\", function () {\r",
									"    pm.expect(response.views).to.eql(0);\r",
									"});\r",
									"\r",
									"pm.test(\"CreatedOn is valid timestamp\", function () {\r",
									"    pm.expect(response.createdOn).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});\r",
									"\r",
									"pm.test(\"PublishedOn is null\", function () {\r",
									"    pm.expect(response.publishedOn).to.be.null;\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"annotation\": \"Сплав на байдарках похож на полет.\",\r\n  \"category\": {{category_id}},\r\n  \"description\": \"Сплав на байдарках похож на полет. На спокойной воде — это парение. На бурной, порожистой — выполнение фигур высшего пилотажа. И то, и другое дарят чувство обновления, феерические эмоции, яркие впечатления.\",\r\n  \"eventDate\": \"2025-12-31 15:10:05\",\r\n  \"location\": {\r\n    \"lat\": 55.754167,\r\n    \"lon\": 37.62\r\n  },\r\n  \"paid\": true,\r\n  \"participantLimit\": 10,\r\n  \"requestModeration\": false,\r\n  \"title\": \"Сплав на байдарках\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/{{user_id}}/events",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{user_id}}",
								"events"
							]
						}
					},
					"response": []
				},
				{
					"name": "Post event with  invalid date in past",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// Шаг 1: Создаём нового пользователя\r",
									"const userEmail = `user_${timestamp}@test.com`;\r",
									"const userName = `Test User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const user = res.json();\r",
									"        console.log(\"Создан пользователь с ID:\", user.id);\r",
									"        \r",
									"        // Шаг 2: Создаём новую категорию\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err2, res2) {\r",
									"            if (err2) {\r",
									"                console.error(\"Ошибка при создании категории:\", err2);\r",
									"            } else {\r",
									"                const category = res2.json();\r",
									"                console.log(\"Создана категория с ID:\", category.id);\r",
									"                \r",
									"                // Сохраняем id пользователя и категории для основного запроса\r",
									"                pm.variables.set(\"user_id\", user.id);\r",
									"                pm.variables.set(\"category_id\", category.id);\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 409 Conflict\", function () {\r",
									"    pm.response.to.have.status(409);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is FORBIDDEN\", function () {\r",
									"    pm.expect(response.status).to.eql(\"FORBIDDEN\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is For the requested operation the conditions are not met.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"For the requested operation the conditions are not met.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message contains 'eventDate' and 'еще не наступила'\", function () {\r",
									"    const message = response.message;\r",
									"    pm.expect(message).to.include(\"eventDate\");\r",
									"    pm.expect(message).to.include(\"должно содержать дату, которая еще не наступила\");\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    // Проверяем формат \"yyyy-MM-dd HH:mm:ss\"\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"annotation\": \"Test event with past date\",\r\n  \"category\": {{category_id}},\r\n  \"description\": \"This event is in the past and should not be created\",\r\n  \"eventDate\": \"2020-01-01 12:00:00\",\r\n  \"location\": {\r\n    \"lat\": 55.754167,\r\n    \"lon\": 37.62\r\n  },\r\n  \"paid\": false,\r\n  \"participantLimit\": 0,\r\n  \"requestModeration\": false,\r\n  \"title\": \"Past Event Test\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/1/events",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"1",
								"events"
							]
						}
					},
					"response": []
				},
				{
					"name": "Post event wit event date less then 2 hours from now ",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// --- Создание пользователя ---\r",
									"const userEmail = `user_${timestamp}@test.com`;\r",
									"const userName = `Test User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const user = res.json();\r",
									"        console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"        // --- Создание категории ---\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err2, res2) {\r",
									"            if (err2) {\r",
									"                console.error(\"Ошибка при создании категории:\", err2);\r",
									"            } else {\r",
									"                const category = res2.json();\r",
									"                console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"                // --- Генерация eventDate через 1 час в UTC ---\r",
									"                const oneHourLater = new Date(Date.now() + 60 * 60 * 1000);\r",
									"                // Форматируем в UTC, как \"yyyy-MM-dd HH:mm:ss\"\r",
									"                const year = oneHourLater.getUTCFullYear();\r",
									"                const month = String(oneHourLater.getUTCMonth() + 1).padStart(2, '0');\r",
									"                const day = String(oneHourLater.getUTCDate()).padStart(2, '0');\r",
									"                const hours = String(oneHourLater.getUTCHours()).padStart(2, '0');\r",
									"                const minutes = String(oneHourLater.getUTCMinutes()).padStart(2, '0');\r",
									"                const seconds = String(oneHourLater.getUTCSeconds()).padStart(2, '0');\r",
									"\r",
									"                const formattedDate = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;\r",
									"                console.log(\"Generated eventDate (UTC):\", formattedDate);\r",
									"\r",
									"                // Сохраняем ID и дату для основного запроса\r",
									"                pm.variables.set(\"user_id\", user.id);\r",
									"                pm.variables.set(\"category_id\", category.id);\r",
									"                pm.variables.set(\"event_date_1_hour\", formattedDate);\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- Проверка статуса ---\r",
									"pm.test(\"Status code is 409 Conflict\", function () {\r",
									"    pm.response.to.have.status(409);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"// --- Проверка структуры ответа ---\r",
									"pm.test(\"Response has correct keys\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"// --- Проверка значений полей ---\r",
									"pm.test(\"Status is FORBIDDEN\", function () {\r",
									"    pm.expect(response.status).to.eql(\"FORBIDDEN\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason matches specification\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"For the requested operation the conditions are not met.\");\r",
									"});\r",
									"\r",
									"// --- Проверка сообщения ---\r",
									"pm.test(\"Message matches specification exactly\", function () {\r",
									"    const expectedMessage = `Field: eventDate. Error: Event date must be at least 2 hours from now. Value: ${pm.variables.get(\"event_date_1_hour\")}`;\r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"// --- Проверка формата timestamp ---\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"annotation\": \"Test event in 1 hour UTC (should fail)\",\r\n  \"category\": {{category_id}},\r\n  \"description\": \"This event is scheduled 1 hour from now UTC, which is less than the required 2 hours.\",\r\n  \"eventDate\": \"{{event_date_1_hour}}\",\r\n  \"location\": {\r\n    \"lat\": 55.754167,\r\n    \"lon\": 37.62\r\n  },\r\n  \"paid\": false,\r\n  \"participantLimit\": 0,\r\n  \"requestModeration\": false,\r\n  \"title\": \"Event in 1 Hour UTC Test\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/{{user_id}}/events",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{user_id}}",
								"events"
							]
						}
					},
					"response": []
				},
				{
					"name": "Post event with annotation blank",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// --- Создание пользователя ---\r",
									"const userEmail = `user_${timestamp}@test.com`;\r",
									"const userName = `Test User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const user = res.json();\r",
									"        console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"        // --- Создание категории ---\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err2, res2) {\r",
									"            if (err2) {\r",
									"                console.error(\"Ошибка при создании категории:\", err2);\r",
									"            } else {\r",
									"                const category = res2.json();\r",
									"                console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"                // Сохраняем ID для основного запроса\r",
									"                pm.variables.set(\"user_id\", user.id);\r",
									"                pm.variables.set(\"category_id\", category.id);\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 Bad Request\", function () {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is BAD_REQUEST\", function () {\r",
									"    pm.expect(response.status).to.eql(\"BAD_REQUEST\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Incorrectly made request.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Incorrectly made request.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message contains 'annotation' and 'must not be blank'\", function () {\r",
									"    const message = response.message;\r",
									"    pm.expect(message).to.include(\"Field: annotation\");\r",
									"    pm.expect(message).to.include(\"Error: must not be blank\");\r",
									"    pm.expect(message).to.include(\"Value: null\");\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"annotation\": null,\r\n  \"category\": {{category_id}},\r\n  \"description\": \"Valid description longer than 20 chars.\",\r\n  \"eventDate\": \"2025-12-31 15:10:05\",\r\n  \"location\": {\r\n    \"lat\": 55.754167,\r\n    \"lon\": 37.62\r\n  },\r\n  \"paid\": false,\r\n  \"participantLimit\": 0,\r\n  \"requestModeration\": true,\r\n  \"title\": \"Valid Title\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/{{user_id}}/events",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{user_id}}",
								"events"
							]
						}
					},
					"response": []
				},
				{
					"name": "Post event with category null",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// --- Создание пользователя ---\r",
									"const userEmail = `user_${timestamp}@test.com`;\r",
									"const userName = `Test User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const user = res.json();\r",
									"        console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"        // --- Создание категории ---\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err2, res2) {\r",
									"            if (err2) {\r",
									"                console.error(\"Ошибка при создании категории:\", err2);\r",
									"            } else {\r",
									"                const category = res2.json();\r",
									"                console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"                // Сохраняем ID для основного запроса\r",
									"                pm.variables.set(\"user_id\", user.id);\r",
									"                pm.variables.set(\"category_id\", category.id);\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 Bad Request\", function () {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is BAD_REQUEST\", function () {\r",
									"    pm.expect(response.status).to.eql(\"BAD_REQUEST\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Incorrectly made request.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Incorrectly made request.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message contains 'category' and 'must not be null'\", function () {\r",
									"    const message = response.message;\r",
									"    pm.expect(message).to.include(\"Field: category\");\r",
									"    pm.expect(message).to.include(\"Error: must not be null\");\r",
									"    pm.expect(message).to.include(\"Value: null\");\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"annotation\": \"Valid annotation longer than 20 chars.\",\r\n  \"category\": null,\r\n  \"description\": \"Valid description longer than 20 chars.\",\r\n  \"eventDate\": \"2025-12-31 15:10:05\",\r\n  \"location\": {\r\n    \"lat\": 55.754167,\r\n    \"lon\": 37.62\r\n  },\r\n  \"paid\": false,\r\n  \"participantLimit\": 0,\r\n  \"requestModeration\": true,\r\n  \"title\": \"Valid Title\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/{{user_id}}/events",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{user_id}}",
								"events"
							]
						}
					},
					"response": []
				},
				{
					"name": "Post event with description blank",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// --- Создание пользователя ---\r",
									"const userEmail = `user_${timestamp}@test.com`;\r",
									"const userName = `Test User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const user = res.json();\r",
									"        console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"        // --- Создание категории ---\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err2, res2) {\r",
									"            if (err2) {\r",
									"                console.error(\"Ошибка при создании категории:\", err2);\r",
									"            } else {\r",
									"                const category = res2.json();\r",
									"                console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"                // Сохраняем ID для основного запроса\r",
									"                pm.variables.set(\"user_id\", user.id);\r",
									"                pm.variables.set(\"category_id\", category.id);\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 Bad Request\", function () {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is BAD_REQUEST\", function () {\r",
									"    pm.expect(response.status).to.eql(\"BAD_REQUEST\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Incorrectly made request.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Incorrectly made request.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message contains 'description' and 'must not be blank'\", function () {\r",
									"    const message = response.message;\r",
									"    pm.expect(message).to.include(\"Field: description\");\r",
									"    pm.expect(message).to.include(\"Error: must not be blank\");\r",
									"    pm.expect(message).to.include(\"Value: null\");\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"annotation\": \"Valid annotation longer than 20 chars.\",\r\n  \"category\": {{category_id}},\r\n  \"description\": null,\r\n  \"eventDate\": \"2025-12-31 15:10:05\",\r\n  \"location\": {\r\n    \"lat\": 55.754167,\r\n    \"lon\": 37.62\r\n  },\r\n  \"paid\": false,\r\n  \"participantLimit\": 0,\r\n  \"requestModeration\": true,\r\n  \"title\": \"Valid Title\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/{{user_id}}/events",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{user_id}}",
								"events"
							]
						}
					},
					"response": []
				},
				{
					"name": "Post event with event date null",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// --- Создание пользователя ---\r",
									"const userEmail = `user_${timestamp}@test.com`;\r",
									"const userName = `Test User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const user = res.json();\r",
									"        console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"        // --- Создание категории ---\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err2, res2) {\r",
									"            if (err2) {\r",
									"                console.error(\"Ошибка при создании категории:\", err2);\r",
									"            } else {\r",
									"                const category = res2.json();\r",
									"                console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"                // Сохраняем ID для основного запроса\r",
									"                pm.variables.set(\"user_id\", user.id);\r",
									"                pm.variables.set(\"category_id\", category.id);\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 Bad Request\", function () {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is BAD_REQUEST\", function () {\r",
									"    pm.expect(response.status).to.eql(\"BAD_REQUEST\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Incorrectly made request.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Incorrectly made request.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message contains 'eventDate' and 'must not be null'\", function () {\r",
									"    const message = response.message;\r",
									"    pm.expect(message).to.include(\"Field: eventDate\");\r",
									"    pm.expect(message).to.include(\"Error: must not be null\");\r",
									"    pm.expect(message).to.include(\"Value: null\");\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"annotation\": \"Valid annotation longer than 20 chars.\",\r\n  \"category\": {{category_id}},\r\n  \"description\": \"Valid description longer than 20 chars.\",\r\n  \"eventDate\": null,\r\n  \"location\": {\r\n    \"lat\": 55.754167,\r\n    \"lon\": 37.62\r\n  },\r\n  \"paid\": false,\r\n  \"participantLimit\": 0,\r\n  \"requestModeration\": true,\r\n  \"title\": \"Valid Title\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/{{user_id}}/events",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{user_id}}",
								"events"
							]
						}
					},
					"response": []
				},
				{
					"name": "Post event with null location",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// --- Создание пользователя ---\r",
									"const userEmail = `user_${timestamp}@test.com`;\r",
									"const userName = `Test User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const user = res.json();\r",
									"        console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"        // --- Создание категории ---\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err2, res2) {\r",
									"            if (err2) {\r",
									"                console.error(\"Ошибка при создании категории:\", err2);\r",
									"            } else {\r",
									"                const category = res2.json();\r",
									"                console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"                // Сохраняем ID для основного запроса\r",
									"                pm.variables.set(\"user_id\", user.id);\r",
									"                pm.variables.set(\"category_id\", category.id);\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 Bad Request\", function () {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is BAD_REQUEST\", function () {\r",
									"    pm.expect(response.status).to.eql(\"BAD_REQUEST\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Incorrectly made request.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Incorrectly made request.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message contains 'location' and 'must not be null'\", function () {\r",
									"    const message = response.message;\r",
									"    pm.expect(message).to.include(\"Field: location\");\r",
									"    pm.expect(message).to.include(\"Error: must not be null\");\r",
									"    pm.expect(message).to.include(\"Value: null\");\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"annotation\": \"Valid annotation longer than 20 chars.\",\r\n  \"category\": {{category_id}},\r\n  \"description\": \"Valid description longer than 20 chars.\",\r\n  \"eventDate\": \"2025-12-31 15:10:05\",\r\n  \"location\": null,\r\n  \"paid\": false,\r\n  \"participantLimit\": 0,\r\n  \"requestModeration\": true,\r\n  \"title\": \"Valid Title\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/{{user_id}}/events",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{user_id}}",
								"events"
							]
						}
					},
					"response": []
				},
				{
					"name": "Post event with title null",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// --- Создание пользователя ---\r",
									"const userEmail = `user_${timestamp}@test.com`;\r",
									"const userName = `Test User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const user = res.json();\r",
									"        console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"        // --- Создание категории ---\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err2, res2) {\r",
									"            if (err2) {\r",
									"                console.error(\"Ошибка при создании категории:\", err2);\r",
									"            } else {\r",
									"                const category = res2.json();\r",
									"                console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"                // Сохраняем ID для основного запроса\r",
									"                pm.variables.set(\"user_id\", user.id);\r",
									"                pm.variables.set(\"category_id\", category.id);\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 Bad Request\", function () {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.have.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is BAD_REQUEST\", function () {\r",
									"    pm.expect(response.status).to.eql(\"BAD_REQUEST\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Incorrectly made request.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Incorrectly made request.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message contains 'title' and 'must not be blank'\", function () {\r",
									"    const message = response.message;\r",
									"    pm.expect(message).to.include(\"Field: title\");\r",
									"    pm.expect(message).to.include(\"Error: must not be blank\");\r",
									"    pm.expect(message).to.include(\"Value: null\");\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"annotation\": \"Valid annotation longer than 20 chars.\",\r\n  \"category\": {{category_id}},\r\n  \"description\": \"Valid description longer than 20 chars.\",\r\n  \"eventDate\": \"2025-12-31 15:10:05\",\r\n  \"location\": {\r\n    \"lat\": 55.754167,\r\n    \"lon\": 37.62\r\n  },\r\n  \"paid\": false,\r\n  \"participantLimit\": 0,\r\n  \"requestModeration\": true,\r\n  \"title\": null\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/{{user_id}}/events",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{user_id}}",
								"events"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get user's events without parametrs",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// --- Шаг 1: Создание пользователя ---\r",
									"const userEmail = `user_${timestamp}@test.com`;\r",
									"const userName = `Test User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const user = res.json();\r",
									"        console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"        // --- Шаг 2: Создание категории ---\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err2, res2) {\r",
									"            if (err2) {\r",
									"                console.error(\"Ошибка при создании категории:\", err2);\r",
									"            } else {\r",
									"                const category = res2.json();\r",
									"                console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"                // --- Шаг 3: Создание событий ---\r",
									"                const eventsToCreate = 3;\r",
									"                let createdEventsCount = 0;\r",
									"                const createdEventIds = [];\r",
									"\r",
									"                function createEvent(index) {\r",
									"                    if (index >= eventsToCreate) {\r",
									"                        console.log(`Создано ${eventsToCreate} событий. IDs:`, createdEventIds);\r",
									"                        // Сохраняем ID пользователя и категории для основного запроса\r",
									"                        pm.variables.set(\"user_id\", user.id);\r",
									"                        pm.variables.set(\"category_id\", category.id);\r",
									"                        // Опционально: сохраняем ID событий для более точной проверки\r",
									"                        pm.variables.set(\"created_event_ids\", createdEventIds.join(','));\r",
									"                        return;\r",
									"                    }\r",
									"\r",
									"                    const eventPayload = {\r",
									"                        annotation: `Annotation for Event ${index + 1} by ${userName}`,\r",
									"                        category: category.id,\r",
									"                        description: `Detailed description for Event ${index + 1}. This event tests the GET /users/{userId}/events endpoint.`,\r",
									"                        eventDate: new Date(Date.now() + (index + 3) * 24 * 60 * 60 * 1000).toISOString().replace('T', ' ').substring(0, 19), // Через (index+3) дней\r",
									"                        location: {\r",
									"                            lat: 55.754167 + index * 0.01, // Немного меняем координаты\r",
									"                            lon: 37.62 + index * 0.01\r",
									"                        },\r",
									"                        paid: index % 2 === 0, // Чередуем платные/бесплатные\r",
									"                        participantLimit: 10 + index * 5,\r",
									"                        requestModeration: true,\r",
									"                        title: `Event ${index + 1} Title`\r",
									"                    };\r",
									"\r",
									"                    pm.sendRequest({\r",
									"                        url: `${baseUrl}/users/${user.id}/events`,\r",
									"                        method: 'POST',\r",
									"                        header: { 'Content-Type': 'application/json' },\r",
									"                        body: JSON.stringify(eventPayload)\r",
									"                    }, function (err3, res3) {\r",
									"                        if (err3) {\r",
									"                            console.error(`Ошибка при создании события ${index + 1}:`, err3);\r",
									"                        } else {\r",
									"                            const event = res3.json();\r",
									"                            console.log(`Создано событие ${index + 1} с ID:`, event.id);\r",
									"                            createdEventIds.push(event.id);\r",
									"                        }\r",
									"                        createEvent(index + 1);\r",
									"                    });\r",
									"                }\r",
									"\r",
									"                createEvent(0);\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- Проверка статуса ---\r",
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"// --- Проверка структуры ответа ---\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(response)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Response array has 3 events\", function () {\r",
									"    pm.expect(response.length).to.eql(3);\r",
									"});\r",
									"\r",
									"// --- Проверка структуры каждого события ---\r",
									"response.forEach((event, index) => {\r",
									"    pm.test(`Event ${index + 1} has correct EventShortDto structure`, function () {\r",
									"        // Проверяем наличие обязательных ключей согласно EventShortDto\r",
									"        pm.expect(event).to.include.all.keys(\r",
									"            'id', 'title', 'annotation', 'category', 'paid',\r",
									"            'eventDate', 'initiator', 'confirmedRequests', 'views'\r",
									"        );\r",
									"\r",
									"        // Проверки типов и структур вложенных объектов\r",
									"        pm.expect(event.id).to.be.a('number');\r",
									"        pm.expect(event.title).to.be.a('string');\r",
									"        pm.expect(event.annotation).to.be.a('string');\r",
									"        pm.expect(event.paid).to.be.a('boolean');\r",
									"        pm.expect(event.eventDate).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"        pm.expect(event.confirmedRequests).to.be.a('number');\r",
									"        pm.expect(event.views).to.be.a('number');\r",
									"\r",
									"        // Проверка структуры category\r",
									"        pm.expect(event.category).to.include.all.keys('id', 'name');\r",
									"        pm.expect(event.category.id).to.be.a('number');\r",
									"        pm.expect(event.category.name).to.be.a('string');\r",
									"\r",
									"        // Проверка структуры initiator\r",
									"        pm.expect(event.initiator).to.include.all.keys('id', 'name');\r",
									"        pm.expect(event.initiator.id).to.be.a('number');\r",
									"        pm.expect(event.initiator.name).to.be.a('string');\r",
									"    });\r",
									"});\r",
									"\r",
									"// --- Опционально: Проверка ID событий ---\r",
									"pm.test(\"Returned event IDs match created ones\", function () {\r",
									"    const createdIdsString = pm.variables.get(\"created_event_ids\");\r",
									"    if (createdIdsString) {\r",
									"        const createdIds = createdIdsString.split(',').map(id => parseInt(id.trim(), 10));\r",
									"        const returnedIds = response.map(e => e.id);\r",
									"        pm.expect(returnedIds).to.have.members(createdIds);\r",
									"        pm.expect(createdIds).to.have.members(returnedIds); // Проверка наоборот для полной уверенности\r",
									"    } else {\r",
									"        console.warn(\"IDs созданных событий не были сохранены в переменной.\");\r",
									"    }\r",
									"});\r",
									"\r",
									"// --- Опционально: Проверка, что все события принадлежат пользователю ---\r",
									"pm.test(\"All returned events belong to the correct user\", function () {\r",
									"    const userId = parseInt(pm.variables.get(\"user_id\"), 10);\r",
									"    response.forEach(event => {\r",
									"        pm.expect(event.initiator.id).to.eql(userId);\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/users/{{user_id}}/events",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{user_id}}",
								"events"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get user's events with parametrs from=2, size=2",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// --- Шаг 1: Создание пользователя ---\r",
									"const userEmail = `user_${timestamp}@test.com`;\r",
									"const userName = `Test User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"    } else {\r",
									"        const user = res.json();\r",
									"        console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"        // --- Шаг 2: Создание категории ---\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err2, res2) {\r",
									"            if (err2) {\r",
									"                console.error(\"Ошибка при создании категории:\", err2);\r",
									"            } else {\r",
									"                const category = res2.json();\r",
									"                console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"                // --- Шаг 3: Создание 5 событий ---\r",
									"                const eventsToCreate = 5;\r",
									"                let createdEventsCount = 0;\r",
									"                const createdEventDetails = []; // Будем хранить детали для проверки пагинации\r",
									"\r",
									"                function createEvent(index) {\r",
									"                    if (index >= eventsToCreate) {\r",
									"                        console.log(`Создано ${eventsToCreate} событий.`);\r",
									"                        // Сохраняем ID пользователя и категории для основного запроса\r",
									"                        pm.variables.set(\"user_id\", user.id);\r",
									"                        pm.variables.set(\"category_id\", category.id);\r",
									"                        // Сохраняем детали созданных событий (id, title, annotation) для проверки в Tests\r",
									"                        pm.variables.set(\"created_event_details\", JSON.stringify(createdEventDetails));\r",
									"                        return;\r",
									"                    }\r",
									"\r",
									"                    const eventPayload = {\r",
									"                        annotation: `Annotation for Event ${index + 1} by ${userName}`,\r",
									"                        category: category.id,\r",
									"                        description: `Detailed description for Event ${index + 1}. This event tests pagination.`,\r",
									"                        eventDate: new Date(Date.now() + (index + 3) * 24 * 60 * 60 * 1000).toISOString().replace('T', ' ').substring(0, 19), // Через (index+3) дней\r",
									"                        location: {\r",
									"                            lat: 55.754167 + index * 0.01,\r",
									"                            lon: 37.62 + index * 0.01\r",
									"                        },\r",
									"                        paid: index % 2 === 0,\r",
									"                        participantLimit: 10 + index * 5,\r",
									"                        requestModeration: true,\r",
									"                        title: `Event ${index + 1} Title`\r",
									"                    };\r",
									"\r",
									"                    pm.sendRequest({\r",
									"                        url: `${baseUrl}/users/${user.id}/events`,\r",
									"                        method: 'POST',\r",
									"                        header: { 'Content-Type': 'application/json' },\r",
									"                        body: JSON.stringify(eventPayload)\r",
									"                    }, function (err3, res3) {\r",
									"                        if (err3) {\r",
									"                            console.error(`Ошибка при создании события ${index + 1}:`, err3);\r",
									"                        } else {\r",
									"                            const event = res3.json();\r",
									"                            console.log(`Создано событие ${index + 1} с ID:`, event.id);\r",
									"                            // Сохраняем детали для последующей проверки\r",
									"                            createdEventDetails.push({\r",
									"                                id: event.id,\r",
									"                                title: event.title,\r",
									"                                annotation: event.annotation\r",
									"                            });\r",
									"                        }\r",
									"                        createEvent(index + 1);\r",
									"                    });\r",
									"                }\r",
									"\r",
									"                createEvent(0);\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- Проверка статуса ---\r",
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"// --- Проверка структуры ответа ---\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(response)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Response array has exactly 2 events\", function () {\r",
									"    pm.expect(response.length).to.eql(2);\r",
									"});\r",
									"\r",
									"// --- Проверка структуры каждого события ---\r",
									"response.forEach((event, index) => {\r",
									"    pm.test(`Event ${index + 1} has correct EventShortDto structure`, function () {\r",
									"        // Проверяем наличие обязательных ключей согласно EventShortDto\r",
									"        pm.expect(event).to.include.all.keys(\r",
									"            'id', 'title', 'annotation', 'category', 'paid',\r",
									"            'eventDate', 'initiator', 'confirmedRequests', 'views'\r",
									"        );\r",
									"\r",
									"        // Проверки типов и структур вложенных объектов\r",
									"        pm.expect(event.id).to.be.a('number');\r",
									"        pm.expect(event.title).to.be.a('string');\r",
									"        pm.expect(event.annotation).to.be.a('string');\r",
									"        pm.expect(event.paid).to.be.a('boolean');\r",
									"        pm.expect(event.eventDate).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"        pm.expect(event.confirmedRequests).to.be.a('number');\r",
									"        pm.expect(event.views).to.be.a('number');\r",
									"\r",
									"        // Проверка структуры category\r",
									"        pm.expect(event.category).to.include.all.keys('id', 'name');\r",
									"        pm.expect(event.category.id).to.be.a('number');\r",
									"        pm.expect(event.category.name).to.be.a('string');\r",
									"\r",
									"        // Проверка структуры initiator\r",
									"        pm.expect(event.initiator).to.include.all.keys('id', 'name');\r",
									"        pm.expect(event.initiator.id).to.be.a('number');\r",
									"        pm.expect(event.initiator.name).to.be.a('string');\r",
									"    });\r",
									"});\r",
									"\r",
									"\r",
									"// --- Проверка пагинации: соответствие ожидаемым событиям ---\r",
									"pm.test(\"Returned events match expected paginated results (from=2, size=2)\", function () {\r",
									"    const createdDetailsString = pm.variables.get(\"created_event_details\");\r",
									"    if (!createdDetailsString) {\r",
									"         pm.expect.fail(\"Детали созданных событий не были сохранены в переменной.\");\r",
									"    }\r",
									"\r",
									"    let createdDetails;\r",
									"    try {\r",
									"        createdDetails = JSON.parse(createdDetailsString);\r",
									"    } catch (e) {\r",
									"         pm.expect.fail(\"Не удалось распарсить детали созданных событий.\");\r",
									"    }\r",
									"\r",
									"    // Ожидаем события с индексами 2 и 3 (from=2, size=2)\r",
									"    // createdDetails[2] и createdDetails[3]\r",
									"    if (createdDetails.length < 4) {\r",
									"         pm.expect.fail(\"Недостаточно созданных событий для проверки пагинации.\");\r",
									"    }\r",
									"\r",
									"    const expectedThirdEvent = createdDetails[2]; // Индекс 2 -> 3-е событие\r",
									"    const expectedFourthEvent = createdDetails[3]; // Индекс 3 -> 4-е событие\r",
									"\r",
									"    // Проверяем первое возвращенное событие (должно быть 3-е созданное)\r",
									"    pm.expect(response[0].id).to.eql(expectedThirdEvent.id);\r",
									"    pm.expect(response[0].title).to.eql(expectedThirdEvent.title);\r",
									"    pm.expect(response[0].annotation).to.eql(expectedThirdEvent.annotation);\r",
									"\r",
									"    // Проверяем второе возвращенное событие (должно быть 4-е созданное)\r",
									"    pm.expect(response[1].id).to.eql(expectedFourthEvent.id);\r",
									"    pm.expect(response[1].title).to.eql(expectedFourthEvent.title);\r",
									"    pm.expect(response[1].annotation).to.eql(expectedFourthEvent.annotation);\r",
									"});\r",
									"\r",
									"// --- Опционально: Проверка, что все события принадлежат пользователю ---\r",
									"pm.test(\"All returned events belong to the correct user\", function () {\r",
									"    const userId = parseInt(pm.variables.get(\"user_id\"), 10);\r",
									"    response.forEach(event => {\r",
									"        pm.expect(event.initiator.id).to.eql(userId);\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/users/{{user_id}}/events?from=2&size=2",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{user_id}}",
								"events"
							],
							"query": [
								{
									"key": "from",
									"value": "2"
								},
								{
									"key": "size",
									"value": "2"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Get event by id of user",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// --- Шаг 1: Создание пользователя ---\r",
									"const userEmail = `user_${timestamp}@test.com`;\r",
									"const userName = `Test User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"        return;\r",
									"    }\r",
									"    const user = res.json();\r",
									"    console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"    // --- Шаг 2: Создание категории ---\r",
									"    const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/categories`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({ name: categoryName })\r",
									"    }, function (err2, res2) {\r",
									"        if (err2) {\r",
									"            console.error(\"Ошибка при создании категории:\", err2);\r",
									"            return;\r",
									"        }\r",
									"        const category = res2.json();\r",
									"        console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"        // --- Шаг 3: Создание события ---\r",
									"        const eventPayload = {\r",
									"            annotation: \"Annotation for the test event to get full info.\",\r",
									"            category: category.id,\r",
									"            description: \"This is a detailed description of the test event. It provides all necessary information for participants.\",\r",
									"            eventDate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString().replace('T', ' ').substring(0, 19), // Через 3 дня\r",
									"            location: {\r",
									"                lat: 55.754167,\r",
									"                lon: 37.62\r",
									"            },\r",
									"            paid: true,\r",
									"            participantLimit: 10,\r",
									"            requestModeration: false,\r",
									"            title: \"Test Event For Get Full Info\"\r",
									"        };\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/users/${user.id}/events`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify(eventPayload)\r",
									"        }, function (err3, res3) {\r",
									"            if (err3) {\r",
									"                console.error(\"Ошибка при создании события:\", err3);\r",
									"                return;\r",
									"            }\r",
									"            const event = res3.json();\r",
									"            console.log(\"Создано событие с ID:\", event.id);\r",
									"\r",
									"            // --- Сохранение ID для основного запроса ---\r",
									"            pm.variables.set(\"user_id\", user.id);\r",
									"            pm.variables.set(\"category_id\", category.id);\r",
									"            pm.variables.set(\"event_id\", event.id);\r",
									"        });\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- Проверка статуса ---\r",
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"// --- Проверка структуры ответа (EventFullDto) ---\r",
									"pm.test(\"Response has correct EventFullDto structure\", function () {\r",
									"    // Проверяем наличие всех обязательных ключей согласно схеме EventFullDto\r",
									"    pm.expect(response).to.include.all.keys(\r",
									"        'id', 'title', 'annotation', 'category', 'description',\r",
									"        'eventDate', 'initiator', 'location', 'paid', 'participantLimit',\r",
									"        'requestModeration', 'state', 'createdOn', 'views', 'confirmedRequests'\r",
									"        // 'publishedOn' может быть null, проверим отдельно\r",
									"    );\r",
									"\r",
									"    // Проверки типов и форматов\r",
									"    pm.expect(response.id).to.be.a('number');\r",
									"    pm.expect(response.title).to.be.a('string');\r",
									"    pm.expect(response.annotation).to.be.a('string');\r",
									"    pm.expect(response.description).to.be.a('string');\r",
									"    pm.expect(response.eventDate).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"    pm.expect(response.paid).to.be.a('boolean');\r",
									"    pm.expect(response.participantLimit).to.be.a('number');\r",
									"    pm.expect(response.requestModeration).to.be.a('boolean');\r",
									"    pm.expect(response.state).to.be.a('string'); // Enum: PENDING, PUBLISHED, CANCELED\r",
									"    pm.expect(response.createdOn).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"    pm.expect(response.views).to.be.a('number');\r",
									"    pm.expect(response.confirmedRequests).to.be.a('number');\r",
									"\r",
									"    // publishedOn может быть null или датой\r",
									"    if (response.publishedOn !== null) {\r",
									"        pm.expect(response.publishedOn).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"    }\r",
									"\r",
									"    // --- Проверка вложенных объектов ---\r",
									"    // CategoryDto\r",
									"    pm.expect(response.category).to.include.all.keys('id', 'name');\r",
									"    pm.expect(response.category.id).to.be.a('number');\r",
									"    pm.expect(response.category.name).to.be.a('string');\r",
									"\r",
									"    // UserShortDto (initiator)\r",
									"    pm.expect(response.initiator).to.include.all.keys('id', 'name');\r",
									"    pm.expect(response.initiator.id).to.be.a('number');\r",
									"    pm.expect(response.initiator.name).to.be.a('string');\r",
									"\r",
									"    // Location\r",
									"    pm.expect(response.location).to.include.all.keys('lat', 'lon');\r",
									"    pm.expect(response.location.lat).to.be.a('number');\r",
									"    pm.expect(response.location.lon).to.be.a('number');\r",
									"});\r",
									"\r",
									"// --- Проверка соответствия ID ---\r",
									"pm.test(\"Returned event ID matches requested ID\", function () {\r",
									"    const eventId = parseInt(pm.variables.get(\"event_id\"), 10);\r",
									"    pm.expect(response.id).to.eql(eventId);\r",
									"});\r",
									"\r",
									"pm.test(\"Returned event belongs to the correct user (initiator)\", function () {\r",
									"    const userId = parseInt(pm.variables.get(\"user_id\"), 10);\r",
									"    pm.expect(response.initiator.id).to.eql(userId);\r",
									"});\r",
									"\r",
									"pm.test(\"Returned event has the correct category\", function () {\r",
									"    const categoryId = parseInt(pm.variables.get(\"category_id\"), 10);\r",
									"    pm.expect(response.category.id).to.eql(categoryId);\r",
									"});\r",
									"\r",
									"// --- Проверка значений по умолчанию или ожидаемых состояний ---\r",
									"pm.test(\"Event state is PENDING by default after creation\", function () {\r",
									"     // Предполагаем, что событие сразу после создания имеет статус PENDING,\r",
									"     // если не было действия по публикации. Уточни логику своего сервиса.\r",
									"     pm.expect(response.state).to.be.oneOf(['PENDING', 'PUBLISHED']); // На случай, если публикуется автоматически\r",
									"});\r",
									"\r",
									"pm.test(\"Confirmed requests and views are initialized correctly\", function () {\r",
									"    pm.expect(response.confirmedRequests).to.be.a('number');\r",
									"    pm.expect(response.views).to.be.a('number');\r",
									"    // Обычно при создании 0, но могут быть особенности логики\r",
									"    // pm.expect(response.confirmedRequests).to.eql(0);\r",
									"    // pm.expect(response.views).to.eql(0);\r",
									"});\r",
									"\r",
									"// --- Проверка форматов дат ---\r",
									"pm.test(\"All date fields have correct format\", function () {\r",
									"    const dateRegex = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;\r",
									"    pm.expect(response.eventDate).to.match(dateRegex);\r",
									"    pm.expect(response.createdOn).to.match(dateRegex);\r",
									"    if (response.publishedOn !== null) {\r",
									"        pm.expect(response.publishedOn).to.match(dateRegex);\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/users/{{user_id}}/events/{{event_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{user_id}}",
								"events",
								"{{event_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Valid update of event",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"const futureDate = new Date(Date.now() + 2 * 24 * 60 * 60 * 1000);\r",
									"const formattedDate = futureDate.toISOString().replace('T', ' ').substring(0, 19);\r",
									"pm.environment.set(\"updated_event_date\", formattedDate);\r",
									"console.log(\"Set updated_event_date to:\", formattedDate);\r",
									"\r",
									"// --- Шаг 1: Создание пользователя ---\r",
									"const userEmail = `user_${timestamp}@test.com`;\r",
									"const userName = `Test User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"        return;\r",
									"    }\r",
									"    const user = res.json();\r",
									"    console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"    // --- Шаг 2: Создание категории ---\r",
									"    const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/categories`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({ name: categoryName })\r",
									"    }, function (err2, res2) {\r",
									"        if (err2) {\r",
									"            console.error(\"Ошибка при создании категории:\", err2);\r",
									"            return;\r",
									"        }\r",
									"        const category = res2.json();\r",
									"        console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"        // --- Шаг 3: Создание события ---\r",
									"        // Убедимся, что дата события в будущем (не раньше чем через 2 часа)\r",
									"        const futureDate = new Date(Date.now() + 3 * 60 * 60 * 1000); // Через 3 часа\r",
									"        const eventDateStr = futureDate.toISOString().replace('T', ' ').substring(0, 19);\r",
									"\r",
									"        const eventPayload = {\r",
									"            annotation: \"Original annotation for the test event to be updated.\",\r",
									"            category: category.id,\r",
									"            description: \"Original detailed description of the test event. It will be updated shortly.\",\r",
									"            eventDate: eventDateStr,\r",
									"            location: {\r",
									"                lat: 55.754167,\r",
									"                lon: 37.62\r",
									"            },\r",
									"            paid: false,\r",
									"            participantLimit: 0,\r",
									"            requestModeration: true,\r",
									"            title: \"Original Test Event Title\"\r",
									"        };\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/users/${user.id}/events`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify(eventPayload)\r",
									"        }, function (err3, res3) {\r",
									"            if (err3) {\r",
									"                console.error(\"Ошибка при создании события:\", err3);\r",
									"                return;\r",
									"            }\r",
									"            const event = res3.json();\r",
									"            console.log(\"Создано событие с ID:\", event.id);\r",
									"\r",
									"            // --- Сохранение ID для основного запроса ---\r",
									"            pm.variables.set(\"user_id\", user.id);\r",
									"            pm.variables.set(\"category_id\", category.id);\r",
									"            pm.variables.set(\"event_id\", event.id);\r",
									"\r",
									"            // --- Сохранение оригинальных данных для проверки ---\r",
									"            pm.variables.set(\"original_title\", event.title);\r",
									"            pm.variables.set(\"original_annotation\", event.annotation);\r",
									"            pm.variables.set(\"original_description\", event.description);\r",
									"        });\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- Проверка статуса ---\r",
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"// --- Проверка структуры ответа (EventFullDto) ---\r",
									"pm.test(\"Response has correct EventFullDto structure\", function () {\r",
									"    pm.expect(response).to.include.all.keys(\r",
									"        'id', 'title', 'annotation', 'category', 'description',\r",
									"        'eventDate', 'initiator', 'location', 'paid', 'participantLimit',\r",
									"        'requestModeration', 'state', 'createdOn', 'views', 'confirmedRequests'\r",
									"        // 'publishedOn' может быть null\r",
									"    );\r",
									"\r",
									"    // Проверки типов\r",
									"    pm.expect(response.id).to.be.a('number');\r",
									"    pm.expect(response.title).to.be.a('string');\r",
									"    pm.expect(response.annotation).to.be.a('string');\r",
									"    pm.expect(response.description).to.be.a('string');\r",
									"    pm.expect(response.eventDate).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"    pm.expect(response.paid).to.be.a('boolean');\r",
									"    pm.expect(response.participantLimit).to.be.a('number');\r",
									"    pm.expect(response.requestModeration).to.be.a('boolean');\r",
									"    pm.expect(response.state).to.be.a('string'); // Enum: PENDING, PUBLISHED, CANCELED\r",
									"    pm.expect(response.createdOn).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"    pm.expect(response.views).to.be.a('number');\r",
									"    pm.expect(response.confirmedRequests).to.be.a('number');\r",
									"\r",
									"    if (response.publishedOn !== null) {\r",
									"        pm.expect(response.publishedOn).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"    }\r",
									"\r",
									"    // --- Проверка вложенных объектов ---\r",
									"    pm.expect(response.category).to.include.all.keys('id', 'name');\r",
									"    pm.expect(response.category.id).to.be.a('number');\r",
									"    pm.expect(response.category.name).to.be.a('string');\r",
									"\r",
									"    pm.expect(response.initiator).to.include.all.keys('id', 'name');\r",
									"    pm.expect(response.initiator.id).to.be.a('number');\r",
									"    pm.expect(response.initiator.name).to.be.a('string');\r",
									"\r",
									"    pm.expect(response.location).to.include.all.keys('lat', 'lon');\r",
									"    pm.expect(response.location.lat).to.be.a('number');\r",
									"    pm.expect(response.location.lon).to.be.a('number');\r",
									"});\r",
									"\r",
									"// --- Проверка обновлённых данных ---\r",
									"pm.test(\"Event title is updated correctly\", function () {\r",
									"    pm.expect(response.title).to.eql(\"Updated Event Title\");\r",
									"});\r",
									"\r",
									"pm.test(\"Event annotation is updated correctly\", function () {\r",
									"    pm.expect(response.annotation).to.eql(\"Updated annotation for the test event.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Event description is updated correctly\", function () {\r",
									"    pm.expect(response.description).to.eql(\"This is the completely updated and detailed description of the test event.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Event paid status is updated correctly\", function () {\r",
									"    pm.expect(response.paid).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Event participant limit is updated correctly\", function () {\r",
									"    pm.expect(response.participantLimit).to.eql(50);\r",
									"});\r",
									"\r",
									"pm.test(\"Event request moderation is updated correctly\", function () {\r",
									"    pm.expect(response.requestModeration).to.be.false;\r",
									"});\r",
									"\r",
									"// --- Проверка неизменённых ключевых данных ---\r",
									"pm.test(\"Event ID remains unchanged\", function () {\r",
									"    const eventId = parseInt(pm.variables.get(\"event_id\"), 10);\r",
									"    pm.expect(response.id).to.eql(eventId);\r",
									"});\r",
									"\r",
									"pm.test(\"Event initiator remains unchanged\", function () {\r",
									"    const userId = parseInt(pm.variables.get(\"user_id\"), 10);\r",
									"    pm.expect(response.initiator.id).to.eql(userId);\r",
									"    const userName = pm.variables.get(\"user_name\"); // Если сохранял имя\r",
									"    // pm.expect(response.initiator.name).to.eql(userName);\r",
									"});\r",
									"\r",
									"pm.test(\"Event category remains unchanged\", function () {\r",
									"    const categoryId = parseInt(pm.variables.get(\"category_id\"), 10);\r",
									"    pm.expect(response.category.id).to.eql(categoryId);\r",
									"});\r",
									"\r",
									"// --- Проверка состояния события ---\r",
									"pm.test(\"Event state is still PENDING after update by owner\", function () {\r",
									"    pm.expect(response.state).to.eql(\"PENDING\");\r",
									"    // Согласно спецификации, PATCH от пользователя может изменить только PENDING/CANCELED события.\r",
									"    // Если бы оно было опубликовано, PATCH мог бы вернуть 409.\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"title\": \"Updated Event Title\",\r\n  \"annotation\": \"Updated annotation for the test event.\",\r\n  \"description\": \"This is the completely updated and detailed description of the test event.\",\r\n  \"eventDate\": \"{{updated_event_date}}\",\r\n  \"paid\": true,\r\n  \"participantLimit\": 50,\r\n  \"requestModeration\": false\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/{{user_id}}/events/{{event_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{user_id}}",
								"events",
								"{{event_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update event which user not allowed to update",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// --- Шаг 1: Создание пользователя 1 (владельца события) ---\r",
									"const user1Email = `owner_${timestamp}@test.com`;\r",
									"const user1Name = `Owner User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: user1Email, name: user1Name })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании владельца события:\", err);\r",
									"        return;\r",
									"    }\r",
									"    const user1 = res.json();\r",
									"    console.log(\"Создан владелец события с ID:\", user1.id);\r",
									"\r",
									"    // --- Шаг 2: Создание пользователя 2 (того, кто пытается обновить) ---\r",
									"    const user2Email = `updater_${timestamp}@test.com`;\r",
									"    const user2Name = `Updater User ${timestamp}`;\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/users`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({ email: user2Email, name: user2Name })\r",
									"    }, function (err2, res2) {\r",
									"        if (err2) {\r",
									"            console.error(\"Ошибка при создании пользователя, пытающегося обновить:\", err2);\r",
									"            return;\r",
									"        }\r",
									"        const user2 = res2.json();\r",
									"        console.log(\"Создан пользователь, пытающийся обновить, с ID:\", user2.id);\r",
									"\r",
									"        // --- Шаг 3: Создание категории ---\r",
									"        const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/categories`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({ name: categoryName })\r",
									"        }, function (err3, res3) {\r",
									"            if (err3) {\r",
									"                console.error(\"Ошибка при создании категории:\", err3);\r",
									"                return;\r",
									"            }\r",
									"            const category = res3.json();\r",
									"            console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"            // --- Шаг 4: Создание события от имени user1 ---\r",
									"            // Убедимся, что дата события в будущем (не раньше чем через 2 часа)\r",
									"            const futureDate = new Date(Date.now() + 3 * 60 * 60 * 1000); // Через 3 часа\r",
									"            const eventDateStr = futureDate.toISOString().replace('T', ' ').substring(0, 19);\r",
									"\r",
									"            const eventPayload = {\r",
									"                annotation: \"Annotation for the test event owned by user1.\",\r",
									"                category: category.id,\r",
									"                description: \"Detailed description of the test event. This event is owned by user1 and should not be updatable by user2.\",\r",
									"                eventDate: eventDateStr,\r",
									"                location: {\r",
									"                    lat: 55.754167,\r",
									"                    lon: 37.62\r",
									"                },\r",
									"                paid: false,\r",
									"                participantLimit: 0,\r",
									"                requestModeration: true,\r",
									"                title: \"Test Event Owned By User1\"\r",
									"            };\r",
									"\r",
									"            pm.sendRequest({\r",
									"                url: `${baseUrl}/users/${user1.id}/events`,\r",
									"                method: 'POST',\r",
									"                header: { 'Content-Type': 'application/json' },\r",
									"                body: JSON.stringify(eventPayload)\r",
									"            }, function (err4, res4) {\r",
									"                if (err4) {\r",
									"                    console.error(\"Ошибка при создании события:\", err4);\r",
									"                    return;\r",
									"                }\r",
									"                const event = res4.json();\r",
									"                console.log(\"Создано событие с ID:\", event.id);\r",
									"\r",
									"                // --- Сохранение ID для основного запроса ---\r",
									"                // ВАЖНО: user2 пытается обновить событие user1\r",
									"                pm.variables.set(\"user_id\", user2.id); // Пользователь, пытающийся обновить\r",
									"                pm.variables.set(\"event_id\", event.id); // Событие, владельцем которого является user1\r",
									"                pm.variables.set(\"category_id\", category.id); // Категория (для проверки)\r",
									"            });\r",
									"        });\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 403 FORBIDDEN\", function () {\r",
									"    pm.response.to.have.status(403); // или 409, если у тебя так\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Status is FORBIDDEN\", function () {\r",
									"    pm.expect(response.status).to.eql(\"FORBIDDEN\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is correct\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"For the requested operation the conditions are not met.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message does not contain 'Forbidden from service:'\", function () {\r",
									"    pm.expect(response.message).to.not.include(\"Forbidden from service:\");\r",
									"    pm.expect(response.message).to.include(\"User with id=\");\r",
									"    pm.expect(response.message).to.include(\"is not allowed to update event with id=\");\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"title\": \"Attempted Update By User2\",\r\n  \"annotation\": \"This update should fail because user2 does not own this event.\",\r\n  \"description\": \"User2 is trying to change the description of user1's event.\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/{{user_id}}/events/{{event_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{user_id}}",
								"events",
								"{{event_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update absent event",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"const timestamp = Date.now();\r",
									"\r",
									"// --- Шаг 1: Создание пользователя ---\r",
									"const userEmail = `user_${timestamp}@test.com`;\r",
									"const userName = `Test User ${timestamp}`;\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify({ email: userEmail, name: userName })\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"        return;\r",
									"    }\r",
									"    const user = res.json();\r",
									"    console.log(\"Создан пользователь с ID:\", user.id);\r",
									"\r",
									"    // --- Шаг 2: Создание категории ---\r",
									"    const categoryName = `Test Category ${timestamp}`;\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/categories`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({ name: categoryName })\r",
									"    }, function (err2, res2) {\r",
									"        if (err2) {\r",
									"            console.error(\"Ошибка при создании категории:\", err2);\r",
									"            return;\r",
									"        }\r",
									"        const category = res2.json();\r",
									"        console.log(\"Создана категория с ID:\", category.id);\r",
									"\r",
									"        // --- Шаг 3: Генерация несуществующего eventId ---\r",
									"        // Используем заведомо большой ID, который с большой долей вероятности не существует\r",
									"        const nonExistentEventId = 999999;\r",
									"\r",
									"        // --- Сохранение ID для основного запроса ---\r",
									"        pm.variables.set(\"user_id\", user.id);\r",
									"        pm.variables.set(\"category_id\", category.id);\r",
									"        pm.variables.set(\"event_id\", nonExistentEventId); // eventId, который НЕ СУЩЕСТВУЕТ\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- Проверка статуса ---\r",
									"pm.test(\"Status code is 404 Not Found\", function () {\r",
									"    pm.response.to.have.status(404);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"// --- Проверка структуры ответа (ApiError) ---\r",
									"pm.test(\"Response has correct ApiError structure\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"// --- Проверка значений полей ---\r",
									"pm.test(\"Status is NOT_FOUND\", function () {\r",
									"    pm.expect(response.status).to.eql(\"NOT_FOUND\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is The required object was not found.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"The required object was not found.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message indicates event was not found\", function () {\r",
									"    // Сообщение может быть разным, но часто содержит ID.\r",
									"    // Пример из спецификации: \"Event with id=283 was not found\"\r",
									"    const eventId = pm.variables.get(\"event_id\");\r",
									"    pm.expect(response.message).to.include(`Event with id=${eventId} was not found`);\r",
									"    // Или более общий вариант:\r",
									"    // pm.expect(response.message).to.include(\"Event\");\r",
									"    // pm.expect(response.message).to.include(\"was not found\");\r",
									"});\r",
									"\r",
									"// --- Проверка формата timestamp ---\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"title\": \"Attempted Update Of Non-Existent Event\",\r\n  \"annotation\": \"This update should fail because the event does not exist.\",\r\n  \"description\": \"Trying to update an event that was never created.\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/{{user_id}}/events/{{event_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{user_id}}",
								"events",
								"{{event_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Add succes request with status: PENDING",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"// Создаём двух пользователей: владельца события и заявителя\r",
									"const users = [\r",
									"    { email: `event_owner_${Date.now()}@test.com`, name: \"Event Owner\" },\r",
									"    { email: `requester_${Date.now()}@test.com`, name: \"Requester\" }\r",
									"];\r",
									"\r",
									"const createdUserIds = [];\r",
									"\r",
									"function createUser(index) {\r",
									"    if (index >= users.length) {\r",
									"        pm.variables.set(\"owner_id\", createdUserIds[0]);\r",
									"        pm.variables.set(\"requester_id\", createdUserIds[1]);\r",
									"        console.log(\"Owner ID:\", createdUserIds[0]);\r",
									"        console.log(\"Requester ID:\", createdUserIds[1]);\r",
									"        \r",
									"        // Создаём событие от владельца\r",
									"        createEvent();\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const user = users[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/users`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(user)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании пользователя:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            createdUserIds.push(response.id);\r",
									"        }\r",
									"        createUser(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"function createEvent() {\r",
									"    const owner = createdUserIds[0];\r",
									"    const categoryId = 1; // предполагаем, что категория существует\r",
									"\r",
									"    const event = {\r",
									"        annotation: \"Test event for participation\",\r",
									"        category: categoryId,\r",
									"        description: \"This event is used to test participation requests\",\r",
									"        eventDate: \"2025-12-31 15:00:00\",\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: false,\r",
									"        participantLimit: 10,\r",
									"        requestModeration: true, // ← важно: будет PENDING\r",
									"        title: \"Test Event for Participation\"\r",
									"    };\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/users/${owner}/events`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(event)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            pm.variables.set(\"event_id\", response.id);\r",
									"            console.log(\"Создано событие с ID:\", response.id);\r",
									"            console.log(\"Состояние события:\", response.state); // должно быть PENDING\r",
									"            \r",
									"            // Публикуем событие админом\r",
									"            publishEvent(response.id);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function publishEvent(eventId) {\r",
									"    // PATCH /admin/events/{eventId} с stateAction = PUBLISH_EVENT\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/events/${eventId}`,\r",
									"        method: 'PATCH',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({\r",
									"            stateAction: \"PUBLISH_EVENT\"\r",
									"        })\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при публикации события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            console.log(\"Событие опубликовано, новое состояние:\", response.state); // должно быть PUBLISHED\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"createUser(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 201 Created\", function () {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.include.all.keys(\r",
									"        'id', 'created', 'event', 'requester', 'status'\r",
									"    );\r",
									"});\r",
									"\r",
									"pm.test(\"Request has correct event ID\", function () {\r",
									"    const eventId = Number(pm.variables.get(\"event_id\"));\r",
									"    pm.expect(response.event).to.eql(eventId); // ← не response.event.id, а response.event\r",
									"});\r",
									"\r",
									"pm.test(\"Request has correct requester ID\", function () {\r",
									"    const requesterId = Number(pm.variables.get(\"requester_id\"));\r",
									"    pm.expect(response.requester).to.eql(requesterId); // ← не response.requester.id, а response.requester\r",
									"});\r",
									"\r",
									"pm.test(\"Request status is PENDING\", function () {\r",
									"    pm.expect(response.status).to.eql(\"PENDING\");\r",
									"});\r",
									"\r",
									"pm.test(\"Created timestamp is valid\", function () {\r",
									"    const created = new Date(response.created);\r",
									"    pm.expect(isNaN(created.getTime())).to.be.false;\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{base_url}}/users/{{requester_id}}/requests?eventId={{event_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{requester_id}}",
								"requests"
							],
							"query": [
								{
									"key": "eventId",
									"value": "{{event_id}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Add seccess request to event with false request moderation, request status = CONFIRMED",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"// Создаём двух пользователей: владельца события и заявителя\r",
									"const users = [\r",
									"    { email: `event_owner_${Date.now()}@test.com`, name: \"Event Owner\" },\r",
									"    { email: `requester_${Date.now()}@test.com`, name: \"Requester\" }\r",
									"];\r",
									"\r",
									"const createdUserIds = [];\r",
									"\r",
									"function createUser(index) {\r",
									"    if (index >= users.length) {\r",
									"        pm.variables.set(\"owner_id\", createdUserIds[0]);\r",
									"        pm.variables.set(\"requester_id\", createdUserIds[1]);\r",
									"        console.log(\"Owner ID:\", createdUserIds[0]);\r",
									"        console.log(\"Requester ID:\", createdUserIds[1]);\r",
									"        \r",
									"        // Создаём событие от владельца\r",
									"        createEvent();\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const user = users[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/users`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(user)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании пользователя:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            createdUserIds.push(response.id);\r",
									"        }\r",
									"        createUser(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"function createEvent() {\r",
									"    const owner = createdUserIds[0];\r",
									"    const categoryId = 1; // предполагаем, что категория существует\r",
									"\r",
									"    const event = {\r",
									"        annotation: \"Test event with auto-accept\",\r",
									"        category: categoryId,\r",
									"        description: \"This event does not require request moderation\",\r",
									"        eventDate: \"2025-12-31 15:00:00\",\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: false,\r",
									"        participantLimit: 10,\r",
									"        requestModeration: false, // ← важно: автоматическое подтверждение\r",
									"        title: \"Auto-Accept Event\"\r",
									"    };\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/users/${owner}/events`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(event)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            pm.variables.set(\"event_id\", response.id);\r",
									"            console.log(\"Создано событие с ID:\", response.id);\r",
									"            console.log(\"Состояние события:\", response.state); // должно быть PENDING\r",
									"            \r",
									"            // Публикуем событие админом\r",
									"            publishEvent(response.id);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function publishEvent(eventId) {\r",
									"    // PATCH /admin/events/{eventId} с stateAction = PUBLISH_EVENT\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/events/${eventId}`,\r",
									"        method: 'PATCH',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({\r",
									"            stateAction: \"PUBLISH_EVENT\"\r",
									"        })\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при публикации события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            console.log(\"Событие опубликовано, новое состояние:\", response.state); // должно быть PUBLISHED\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"createUser(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 201 Created\", function () {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.include.all.keys(\r",
									"        'id', 'created', 'event', 'requester', 'status'\r",
									"    );\r",
									"});\r",
									"\r",
									"pm.test(\"Request has correct event ID\", function () {\r",
									"    const eventId = Number(pm.variables.get(\"event_id\"));\r",
									"    pm.expect(response.event).to.eql(eventId);\r",
									"});\r",
									"\r",
									"pm.test(\"Request has correct requester ID\", function () {\r",
									"    const requesterId = Number(pm.variables.get(\"requester_id\"));\r",
									"    pm.expect(response.requester).to.eql(requesterId);\r",
									"});\r",
									"\r",
									"pm.test(\"Request status is CONFIRMED (auto-accepted)\", function () {\r",
									"    pm.expect(response.status).to.eql(\"CONFIRMED\");\r",
									"});\r",
									"\r",
									"pm.test(\"Created timestamp is valid\", function () {\r",
									"    const created = new Date(response.created);\r",
									"    pm.expect(isNaN(created.getTime())).to.be.false;\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{base_url}}/users/{{requester_id}}/requests?eventId={{event_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{requester_id}}",
								"requests"
							],
							"query": [
								{
									"key": "eventId",
									"value": "{{event_id}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Add duplicate request",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"// Создаём двух пользователей: владельца события и заявителя\r",
									"const users = [\r",
									"    { email: `event_owner_${Date.now()}@test.com`, name: \"Event Owner\" },\r",
									"    { email: `requester_${Date.now()}@test.com`, name: \"Requester\" }\r",
									"];\r",
									"\r",
									"const createdUserIds = [];\r",
									"\r",
									"function createUser(index) {\r",
									"    if (index >= users.length) {\r",
									"        pm.variables.set(\"owner_id\", createdUserIds[0]);\r",
									"        pm.variables.set(\"requester_id\", createdUserIds[1]);\r",
									"        console.log(\"Owner ID:\", createdUserIds[0]);\r",
									"        console.log(\"Requester ID:\", createdUserIds[1]);\r",
									"        \r",
									"        // Создаём событие от владельца\r",
									"        createEvent();\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const user = users[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/users`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(user)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании пользователя:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            createdUserIds.push(response.id);\r",
									"        }\r",
									"        createUser(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"function createEvent() {\r",
									"    const owner = createdUserIds[0];\r",
									"    const categoryId = 1; // предполагаем, что категория существует\r",
									"\r",
									"    const event = {\r",
									"        annotation: \"Test event for duplicate request\",\r",
									"        category: categoryId,\r",
									"        description: \"This event is used to test duplicate requests\",\r",
									"        eventDate: \"2025-12-31 15:00:00\",\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: false,\r",
									"        participantLimit: 10,\r",
									"        requestModeration: false, // ← важно: автоматическое подтверждение\r",
									"        title: \"Test Event for Duplicate Request\"\r",
									"    };\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/users/${owner}/events`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(event)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            pm.variables.set(\"event_id\", response.id);\r",
									"            console.log(\"Создано событие с ID:\", response.id);\r",
									"            console.log(\"Состояние события:\", response.state); // должно быть PENDING\r",
									"            \r",
									"            // Публикуем событие админом\r",
									"            publishEvent(response.id);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function publishEvent(eventId) {\r",
									"    // PATCH /admin/events/{eventId} с stateAction = PUBLISH_EVENT\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/events/${eventId}`,\r",
									"        method: 'PATCH',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({\r",
									"            stateAction: \"PUBLISH_EVENT\"\r",
									"        })\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при публикации события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            console.log(\"Событие опубликовано, новое состояние:\", response.state); // должно быть PUBLISHED\r",
									"            \r",
									"            // После публикации — отправляем первую заявку\r",
									"            createFirstRequest(eventId);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function createFirstRequest(eventId) {\r",
									"    const requester = createdUserIds[1];\r",
									"    const url = `${baseUrl}/users/${requester}/requests?eventId=${eventId}`;\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: url,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' }\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании первой заявки:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            console.log(\"Первая заявка создана с ID:\", response.id);\r",
									"            console.log(\"Статус первой заявки:\", response.status); // должен быть CONFIRMED\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"createUser(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 409 Conflict\", function () {\r",
									"    pm.response.to.have.status(409);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure for error\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is CONFLICT\", function () {\r",
									"    pm.expect(response.status).to.eql(\"CONFLICT\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Integrity constraint has been violated.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Integrity constraint has been violated.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message indicates duplicate request\", function () {\r",
									"    const eventId = pm.variables.get(\"event_id\");\r",
									"    const requesterId = pm.variables.get(\"requester_id\");\r",
									"    const expectedMessage = `Event: ${eventId} already contain request from user: ${requesterId}`;\r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{base_url}}/users/{{requester_id}}/requests?eventId={{event_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{requester_id}}",
								"requests"
							],
							"query": [
								{
									"key": "eventId",
									"value": "{{event_id}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Add request by initiator of event",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"// Создаём пользователя (он же владелец и инициатор)\r",
									"const userData = {\r",
									"    email: `event_owner_${Date.now()}@test.com`,\r",
									"    name: \"Event Owner\"\r",
									"};\r",
									"\r",
									"let ownerId, eventId;\r",
									"\r",
									"// Создаём пользователя\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/admin/users`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify(userData)\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании пользователя:\", err);\r",
									"        return;\r",
									"    }\r",
									"    ownerId = res.json().id;\r",
									"    pm.variables.set(\"owner_id\", ownerId);\r",
									"    console.log(\"Owner ID:\", ownerId);\r",
									"\r",
									"    // Создаём событие от владельца\r",
									"    const event = {\r",
									"        annotation: \"Test event for self-request\",\r",
									"        category: 1,\r",
									"        description: \"Owner tries to request to join own event\",\r",
									"        eventDate: \"2025-12-31 15:00:00\",\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: false,\r",
									"        participantLimit: 10,\r",
									"        requestModeration: false,\r",
									"        title: \"Self-Request Event\"\r",
									"    };\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/users/${ownerId}/events`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(event)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании события:\", err);\r",
									"            return;\r",
									"        }\r",
									"        eventId = res.json().id;\r",
									"        pm.variables.set(\"event_id\", eventId);\r",
									"        console.log(\"Создано событие с ID:\", eventId);\r",
									"\r",
									"        // Публикуем событие админом\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/events/${eventId}`,\r",
									"            method: 'PATCH',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({\r",
									"                stateAction: \"PUBLISH_EVENT\"\r",
									"            })\r",
									"        }, function (err, res) {\r",
									"            if (err) {\r",
									"                console.error(\"Ошибка при публикации события:\", err);\r",
									"                return;\r",
									"            }\r",
									"            console.log(\"Событие опубликовано\");\r",
									"        });\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 409 Conflict (owner cannot request)\", function () {\r",
									"    pm.response.to.have.status(409);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure for error\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is CONFLICT\", function () {\r",
									"    pm.expect(response.status).to.eql(\"CONFLICT\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Integrity constraint has been violated.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Integrity constraint has been violated.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message indicates owner cannot request\", function () {\r",
									"    pm.expect(response.message).to.eql(\"Owner of event can not perform request\");\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{base_url}}/users/{{owner_id}}/requests?eventId={{event_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{owner_id}}",
								"requests"
							],
							"query": [
								{
									"key": "eventId",
									"value": "{{event_id}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Add request to unpublished event",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"// Создаём двух пользователей: владельца события и заявителя\r",
									"const users = [\r",
									"    { email: `event_owner_${Date.now()}@test.com`, name: \"Event Owner\" },\r",
									"    { email: `requester_${Date.now()}@test.com`, name: \"Requester\" }\r",
									"];\r",
									"\r",
									"const createdUserIds = [];\r",
									"\r",
									"function createUser(index) {\r",
									"    if (index >= users.length) {\r",
									"        pm.variables.set(\"owner_id\", createdUserIds[0]);\r",
									"        pm.variables.set(\"requester_id\", createdUserIds[1]);\r",
									"        console.log(\"Owner ID:\", createdUserIds[0]);\r",
									"        console.log(\"Requester ID:\", createdUserIds[1]);\r",
									"        \r",
									"        // Создаём событие от владельца\r",
									"        createEvent();\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const user = users[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/users`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(user)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании пользователя:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            createdUserIds.push(response.id);\r",
									"        }\r",
									"        createUser(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"function createEvent() {\r",
									"    const owner = createdUserIds[0];\r",
									"    const categoryId = 1; // предполагаем, что категория существует\r",
									"\r",
									"    const event = {\r",
									"        annotation: \"Unpublished event for request test\",\r",
									"        category: categoryId,\r",
									"        description: \"This event is not published yet\",\r",
									"        eventDate: \"2025-12-31 15:00:00\",\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: false,\r",
									"        participantLimit: 10,\r",
									"        requestModeration: false,\r",
									"        title: \"Unpublished Event\"\r",
									"    };\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/users/${owner}/events`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(event)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            pm.variables.set(\"event_id\", response.id);\r",
									"            console.log(\"Создано событие с ID:\", response.id);\r",
									"            console.log(\"Состояние события:\", response.state); // должно быть PENDING\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"createUser(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 409 Conflict (event not published)\", function () {\r",
									"    pm.response.to.have.status(409);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure for error\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is CONFLICT\", function () {\r",
									"    pm.expect(response.status).to.eql(\"CONFLICT\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Integrity constraint has been violated.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Integrity constraint has been violated.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message indicates event is not published\", function () {\r",
									"    pm.expect(response.message).to.eql(\"Event is not published\");\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{base_url}}/users/{{requester_id}}/requests?eventId={{event_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{requester_id}}",
								"requests"
							],
							"query": [
								{
									"key": "eventId",
									"value": "{{event_id}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Add request to full participent limit",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"// Создаём 5 пользователей\r",
									"const users = [];\r",
									"for (let i = 1; i <= 5; i++) {\r",
									"    users.push({\r",
									"        email: `user${i}_${Date.now()}@test.com`,\r",
									"        name: `User ${i}`\r",
									"    });\r",
									"}\r",
									"\r",
									"const createdUserIds = [];\r",
									"\r",
									"function createUser(index) {\r",
									"    if (index >= users.length) {\r",
									"        console.log(\"Созданы пользователи с ID:\", createdUserIds);\r",
									"        \r",
									"        // Сохраняем нужные ID\r",
									"        pm.variables.set(\"owner_id\", createdUserIds[0]);\r",
									"        pm.variables.set(\"requester2_id\", createdUserIds[1]);\r",
									"        pm.variables.set(\"requester3_id\", createdUserIds[2]);\r",
									"        \r",
									"        // Создаём событие от владельца\r",
									"        createEvent();\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const user = users[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/users`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(user)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании пользователя:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            createdUserIds.push(response.id);\r",
									"        }\r",
									"        createUser(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"function createEvent() {\r",
									"    const owner = createdUserIds[0];\r",
									"    const categoryId = 1;\r",
									"\r",
									"    const event = {\r",
									"        annotation: \"Event with participant limit 2\",\r",
									"        category: categoryId,\r",
									"        description: \"Only 2 participants allowed\",\r",
									"        eventDate: \"2025-12-31 15:00:00\",\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: false,\r",
									"        participantLimit: 2, // ← лимит 2\r",
									"        requestModeration: false, // ← авто-подтверждение\r",
									"        title: \"Limited Event\"\r",
									"    };\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/users/${owner}/events`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(event)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            pm.variables.set(\"event_id\", response.id);\r",
									"            console.log(\"Создано событие с ID:\", response.id);\r",
									"            \r",
									"            // Публикуем событие\r",
									"            publishEvent(response.id);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function publishEvent(eventId) {\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/events/${eventId}`,\r",
									"        method: 'PATCH',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({\r",
									"            stateAction: \"PUBLISH_EVENT\"\r",
									"        })\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при публикации события:\", err);\r",
									"        } else {\r",
									"            console.log(\"Событие опубликовано\");\r",
									"            \r",
									"            // Второй пользователь оставляет заявку\r",
									"            createFirstRequest(eventId);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function createFirstRequest(eventId) {\r",
									"    const requester = createdUserIds[1]; // второй пользователь\r",
									"    const url = `${baseUrl}/users/${requester}/requests?eventId=${eventId}`;\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: url,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' }\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании первой заявки:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            console.log(\"Первая заявка создана, ID:\", response.id);\r",
									"            console.log(\"Статус:\", response.status); // должен быть CONFIRMED\r",
									"            \r",
									"            // Третий пользователь пытается оставить заявку\r",
									"            createSecondRequest(eventId);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function createSecondRequest(eventId) {\r",
									"    const requester = createdUserIds[2]; // третий пользователь\r",
									"    const url = `${baseUrl}/users/${requester}/requests?eventId=${eventId}`;\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: url,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' }\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании второй заявки:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            console.log(\"Вторая заявка создана, ID:\", response.id);\r",
									"            console.log(\"Статус:\", response.status);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"createUser(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 409 Conflict (duplicate request)\", function () {\r",
									"    pm.response.to.have.status(409);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure for error\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is CONFLICT\", function () {\r",
									"    pm.expect(response.status).to.eql(\"CONFLICT\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is Integrity constraint has been violated.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"Integrity constraint has been violated.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message indicates duplicate request\", function () {\r",
									"    const eventId = pm.variables.get(\"event_id\");\r",
									"    const requesterId = pm.variables.get(\"requester3_id\");\r",
									"    const expectedMessage = `Event: ${eventId} already contain request from user: ${requesterId}`;\r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{base_url}}/users/{{requester3_id}}/requests?eventId={{event_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{requester3_id}}",
								"requests"
							],
							"query": [
								{
									"key": "eventId",
									"value": "{{event_id}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Get user requests",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"// Создаём двух пользователей\r",
									"const users = [\r",
									"    { email: `event_owner_${Date.now()}@test.com`, name: \"Event Owner\" },\r",
									"    { email: `requester_${Date.now()}@test.com`, name: \"Requester\" }\r",
									"];\r",
									"\r",
									"const createdUserIds = [];\r",
									"\r",
									"function createUser(index) {\r",
									"    if (index >= users.length) {\r",
									"        pm.variables.set(\"owner_id\", createdUserIds[0]);\r",
									"        pm.variables.set(\"requester_id\", createdUserIds[1]);\r",
									"        console.log(\"Owner ID:\", createdUserIds[0]);\r",
									"        console.log(\"Requester ID:\", createdUserIds[1]);\r",
									"        \r",
									"        // Создаём 2 события\r",
									"        createEvents();\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const user = users[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/users`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(user)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании пользователя:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            createdUserIds.push(response.id);\r",
									"        }\r",
									"        createUser(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"function createEvents() {\r",
									"    const owner = createdUserIds[0];\r",
									"    const categoryId = 1;\r",
									"\r",
									"    const events = [\r",
									"        {\r",
									"            annotation: \"Event 1 for requests\",\r",
									"            category: categoryId,\r",
									"            description: \"First event for testing requests\",\r",
									"            eventDate: \"2025-12-31 15:00:00\",\r",
									"            location: { lat: 55.754167, lon: 37.62 },\r",
									"            paid: false,\r",
									"            participantLimit: 10,\r",
									"            requestModeration: false, // ← без модерации\r",
									"            title: \"Event 1\"\r",
									"        },\r",
									"        {\r",
									"            annotation: \"Event 2 for requests\",\r",
									"            category: categoryId,\r",
									"            description: \"Second event for testing requests\",\r",
									"            eventDate: \"2025-12-30 14:00:00\",\r",
									"            location: { lat: 55.754167, lon: 37.62 },\r",
									"            paid: false,\r",
									"            participantLimit: 5,\r",
									"            requestModeration: false, // ← без модерации\r",
									"            title: \"Event 2\"\r",
									"        }\r",
									"    ];\r",
									"\r",
									"    const createdEventIds = [];\r",
									"\r",
									"    function createEvent(index) {\r",
									"        if (index >= events.length) {\r",
									"            pm.variables.set(\"event1_id\", createdEventIds[0]);\r",
									"            pm.variables.set(\"event2_id\", createdEventIds[1]);\r",
									"            console.log(\"Созданы события с ID:\", createdEventIds);\r",
									"            \r",
									"            // Публикуем оба события\r",
									"            publishEvents(createdEventIds);\r",
									"            return;\r",
									"        }\r",
									"\r",
									"        const event = events[index];\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/users/${owner}/events`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify(event)\r",
									"        }, function (err, res) {\r",
									"            if (err) {\r",
									"                console.error(\"Ошибка при создании события:\", err);\r",
									"            } else {\r",
									"                const response = res.json();\r",
									"                createdEventIds.push(response.id);\r",
									"            }\r",
									"            createEvent(index + 1);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    createEvent(0);\r",
									"}\r",
									"\r",
									"function publishEvents(eventIds) {\r",
									"    function publishEvent(index) {\r",
									"        if (index >= eventIds.length) {\r",
									"            console.log(\"Все события опубликованы\");\r",
									"            \r",
									"            // Второй пользователь оставляет заявки\r",
									"            createRequests(eventIds);\r",
									"            return;\r",
									"        }\r",
									"\r",
									"        const eventId = eventIds[index];\r",
									"        pm.sendRequest({\r",
									"            url: `${baseUrl}/admin/events/${eventId}`,\r",
									"            method: 'PATCH',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify({\r",
									"                stateAction: \"PUBLISH_EVENT\"\r",
									"            })\r",
									"        }, function (err, res) {\r",
									"            if (err) {\r",
									"                console.error(\"Ошибка при публикации события:\", err);\r",
									"            } else {\r",
									"                console.log(`Событие ${eventId} опубликовано`);\r",
									"            }\r",
									"            publishEvent(index + 1);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    publishEvent(0);\r",
									"}\r",
									"\r",
									"function createRequests(eventIds) {\r",
									"    const requester = createdUserIds[1];\r",
									"    \r",
									"    function createRequest(index) {\r",
									"        if (index >= eventIds.length) {\r",
									"            console.log(\"Все заявки созданы\");\r",
									"            return;\r",
									"        }\r",
									"\r",
									"        const eventId = eventIds[index];\r",
									"        const url = `${baseUrl}/users/${requester}/requests?eventId=${eventId}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: url,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' }\r",
									"        }, function (err, res) {\r",
									"            if (err) {\r",
									"                console.error(\"Ошибка при создании заявки:\", err);\r",
									"            } else {\r",
									"                const response = res.json();\r",
									"                console.log(`Заявка на событие ${eventId} создана, ID:`, response.id);\r",
									"            }\r",
									"            createRequest(index + 1);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    createRequest(0);\r",
									"}\r",
									"\r",
									"createUser(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(response)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Response has exactly 2 requests\", function () {\r",
									"    pm.expect(response.length).to.eql(2);\r",
									"});\r",
									"\r",
									"pm.test(\"Each request has correct structure\", function () {\r",
									"    response.forEach(request => {\r",
									"        pm.expect(request).to.include.all.keys(\r",
									"            'id', 'created', 'event', 'requester', 'status'\r",
									"        );\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"All requests belong to the requester\", function () {\r",
									"    const requesterId = Number(pm.variables.get(\"requester_id\"));\r",
									"    response.forEach(request => {\r",
									"        pm.expect(request.requester).to.eql(requesterId);\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Requests are for different events\", function () {\r",
									"    const event1Id = Number(pm.variables.get(\"event1_id\"));\r",
									"    const event2Id = Number(pm.variables.get(\"event2_id\"));\r",
									"    const eventIds = response.map(r => r.event);\r",
									"    \r",
									"    pm.expect(eventIds).to.include(event1Id);\r",
									"    pm.expect(eventIds).to.include(event2Id);\r",
									"});\r",
									"\r",
									"pm.test(\"All requests have status CONFIRMED (auto-accepted)\", function () {\r",
									"    response.forEach(request => {\r",
									"        pm.expect(request.status).to.eql(\"CONFIRMED\");\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamps are valid\", function () {\r",
									"    response.forEach(request => {\r",
									"        const timestamp = new Date(request.created);\r",
									"        pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"        pm.expect(request.created).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/users/{{requester_id}}/requests",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{requester_id}}",
								"requests"
							]
						}
					},
					"response": []
				},
				{
					"name": "Patch request to cancel status",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"// Создаём двух пользователей: владельца события и заявителя\r",
									"const users = [\r",
									"    { email: `event_owner_${Date.now()}@test.com`, name: \"Event Owner\" },\r",
									"    { email: `requester_${Date.now()}@test.com`, name: \"Requester\" }\r",
									"];\r",
									"\r",
									"const createdUserIds = [];\r",
									"\r",
									"function createUser(index) {\r",
									"    if (index >= users.length) {\r",
									"        pm.variables.set(\"owner_id\", createdUserIds[0]);\r",
									"        pm.variables.set(\"requester_id\", createdUserIds[1]);\r",
									"        console.log(\"Owner ID:\", createdUserIds[0]);\r",
									"        console.log(\"Requester ID:\", createdUserIds[1]);\r",
									"        \r",
									"        // Создаём событие от владельца\r",
									"        createEvent();\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const user = users[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/users`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(user)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании пользователя:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            createdUserIds.push(response.id);\r",
									"        }\r",
									"        createUser(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"function createEvent() {\r",
									"    const owner = createdUserIds[0];\r",
									"    const categoryId = 1; // предполагаем, что категория существует\r",
									"\r",
									"    const event = {\r",
									"        annotation: \"Event without request moderation\",\r",
									"        category: categoryId,\r",
									"        description: \"This event auto-confirms requests\",\r",
									"        eventDate: \"2025-12-31 15:00:00\",\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: false,\r",
									"        participantLimit: 10,\r",
									"        requestModeration: false, // ← важно: без модерации\r",
									"        title: \"Auto-Confirm Event\"\r",
									"    };\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/users/${owner}/events`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(event)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            pm.variables.set(\"event_id\", response.id);\r",
									"            console.log(\"Создано событие с ID:\", response.id);\r",
									"            console.log(\"Состояние события:\", response.state); // должно быть PENDING\r",
									"            \r",
									"            // Публикуем событие админом\r",
									"            publishEvent(response.id);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function publishEvent(eventId) {\r",
									"    // PATCH /admin/events/{eventId} с stateAction = PUBLISH_EVENT\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/events/${eventId}`,\r",
									"        method: 'PATCH',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({\r",
									"            stateAction: \"PUBLISH_EVENT\"\r",
									"        })\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при публикации события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            console.log(\"Событие опубликовано, новое состояние:\", response.state); // должно быть PUBLISHED\r",
									"            \r",
									"            // После публикации — отправляем заявку\r",
									"            createRequest(eventId);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function createRequest(eventId) {\r",
									"    const requester = createdUserIds[1];\r",
									"    const url = `${baseUrl}/users/${requester}/requests?eventId=${eventId}`;\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: url,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' }\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании заявки:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            pm.variables.set(\"request_id\", response.id);\r",
									"            console.log(\"Заявка создана с ID:\", response.id);\r",
									"            console.log(\"Статус заявки:\", response.status); // должен быть CONFIRMED\r",
									"            \r",
									"            // Проверим confirmedRequests до отмены\r",
									"            getEventBeforeCancel(eventId);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function getEventBeforeCancel(eventId) {\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/events/${eventId}`,\r",
									"        method: 'GET',\r",
									"        header: { 'Content-Type': 'application/json' }\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при получении события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            pm.collectionVariables.set(\"confirmed_before\", response.confirmedRequests); // ← collectionVariables\r",
									"            console.log(\"Confirmed requests before cancel:\", response.confirmedRequests);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"createUser(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.include.all.keys(\r",
									"        'id', 'created', 'event', 'requester', 'status'\r",
									"    );\r",
									"});\r",
									"\r",
									"pm.test(\"Request ID matches\", function () {\r",
									"    const requestId = Number(pm.variables.get(\"request_id\"));\r",
									"    pm.expect(response.id).to.eql(requestId);\r",
									"});\r",
									"\r",
									"pm.test(\"Requester ID matches\", function () {\r",
									"    const requesterId = Number(pm.variables.get(\"requester_id\"));\r",
									"    pm.expect(response.requester).to.eql(requesterId);\r",
									"});\r",
									"\r",
									"pm.test(\"Event ID matches\", function () {\r",
									"    const eventId = Number(pm.variables.get(\"event_id\"));\r",
									"    pm.expect(response.event).to.eql(eventId);\r",
									"});\r",
									"\r",
									"pm.test(\"Status is CANCELED\", function () {\r",
									"    pm.expect(response.status).to.eql(\"CANCELED\");\r",
									"});\r",
									"\r",
									"pm.test(\"Created timestamp is valid\", function () {\r",
									"    const created = new Date(response.created);\r",
									"    pm.expect(isNaN(created.getTime())).to.be.false;\r",
									"    // Формат: yyyy-MM-dd HH:mm:ss\r",
									"    pm.expect(response.created).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});\r",
									"\r",
									"// Проверяем, что confirmedRequests стало 0\r",
									"setTimeout(() => {\r",
									"    const baseUrl = pm.environment.get(\"base_url\");\r",
									"    const eventId = pm.variables.get(\"event_id\");\r",
									"    const ownerId = pm.variables.get(\"owner_id\");\r",
									"    \r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/users/${ownerId}/events/${eventId}`, // ← эндпоинт пользователя\r",
									"        method: 'GET',\r",
									"        header: { 'Content-Type': 'application/json' }\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при получении события после отмены:\", err);\r",
									"        } else {\r",
									"            const eventResponse = res.json();\r",
									"            console.log(\"Полный ответ от сервера:\", eventResponse);\r",
									"            \r",
									"            const confirmedAfter = eventResponse.confirmedRequests;\r",
									"            \r",
									"            pm.test(\"Confirmed requests is 0 after cancellation\", function () {\r",
									"                pm.expect(confirmedAfter).to.eql(0);\r",
									"            });\r",
									"        }\r",
									"    });\r",
									"}, 1500);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"url": {
							"raw": "{{base_url}}/users/{{requester_id}}/requests/{{request_id}}/cancel",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{requester_id}}",
								"requests",
								"{{request_id}}",
								"cancel"
							]
						}
					},
					"response": []
				},
				{
					"name": "User get requests for his event",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"// Создаём трёх пользователей\r",
									"const users = [\r",
									"    { email: `event_owner_${Date.now()}@test.com`, name: \"Event Owner\" },\r",
									"    { email: `requester1_${Date.now()}@test.com`, name: \"Requester 1\" },\r",
									"    { email: `requester2_${Date.now()}@test.com`, name: \"Requester 2\" }\r",
									"];\r",
									"\r",
									"const createdUserIds = [];\r",
									"\r",
									"function createUser(index) {\r",
									"    if (index >= users.length) {\r",
									"        pm.variables.set(\"owner_id\", createdUserIds[0]);\r",
									"        pm.variables.set(\"requester1_id\", createdUserIds[1]);\r",
									"        pm.variables.set(\"requester2_id\", createdUserIds[2]);\r",
									"        console.log(\"User IDs:\", createdUserIds);\r",
									"        \r",
									"        // Ждём 1 секунду, чтобы переменные точно записались\r",
									"        setTimeout(() => {\r",
									"            createEvent();\r",
									"        }, 1000); // ← добавлено\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const user = users[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/users`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(user)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании пользователя:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            createdUserIds.push(response.id);\r",
									"        }\r",
									"        createUser(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"function createEvent() {\r",
									"    const owner = createdUserIds[0];\r",
									"    const categoryId = 1;\r",
									"\r",
									"    const event = {\r",
									"        annotation: \"Event for requests test\",\r",
									"        category: categoryId,\r",
									"        description: \"This event is used to test event requests\",\r",
									"        eventDate: \"2025-12-31 15:00:00\",\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: false,\r",
									"        participantLimit: 10,\r",
									"        requestModeration: false, // ← без модерации\r",
									"        title: \"Event for Requests Test\"\r",
									"    };\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/users/${owner}/events`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(event)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            pm.variables.set(\"event_id\", response.id);\r",
									"            console.log(\"Создано событие с ID:\", response.id);\r",
									"            \r",
									"            // Публикуем событие\r",
									"            publishEvent(response.id);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function publishEvent(eventId) {\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/events/${eventId}`,\r",
									"        method: 'PATCH',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({\r",
									"            stateAction: \"PUBLISH_EVENT\"\r",
									"        })\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при публикации события:\", err);\r",
									"        } else {\r",
									"            console.log(\"Событие опубликовано\");\r",
									"            \r",
									"            // Оставляем заявки\r",
									"            createRequests(eventId);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function createRequests(eventId) {\r",
									"    const requesters = [createdUserIds[1], createdUserIds[2]]; // 2-й и 3-й пользователи\r",
									"    \r",
									"    function createRequest(index) {\r",
									"        if (index >= requesters.length) {\r",
									"            console.log(\"Все заявки созданы\");\r",
									"            return;\r",
									"        }\r",
									"\r",
									"        const requester = requesters[index];\r",
									"        const url = `${baseUrl}/users/${requester}/requests?eventId=${eventId}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: url,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' }\r",
									"        }, function (err, res) {\r",
									"            if (err) {\r",
									"                console.error(\"Ошибка при создании заявки:\", err);\r",
									"            } else {\r",
									"                const response = res.json();\r",
									"                console.log(`Заявка от пользователя ${requester} создана, ID:`, response.id);\r",
									"            }\r",
									"            createRequest(index + 1);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    createRequest(0);\r",
									"}\r",
									"\r",
									"createUser(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(response)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Response has exactly 2 requests\", function () {\r",
									"    pm.expect(response.length).to.eql(2);\r",
									"});\r",
									"\r",
									"pm.test(\"Each request has correct structure\", function () {\r",
									"    response.forEach(request => {\r",
									"        pm.expect(request).to.include.all.keys(\r",
									"            'id', 'created', 'event', 'requester', 'status'\r",
									"        );\r",
									"    });\r",
									"});\r",
									"\r",
									"// ИСПРАВЛЕНО: event содержит сразу ID, а не объект\r",
									"pm.test(\"All requests are for the correct event\", function () {\r",
									"    const eventId = Number(pm.variables.get(\"event_id\"));\r",
									"    response.forEach(request => {\r",
									"        pm.expect(request.event).to.eql(eventId); // убрал .id\r",
									"    });\r",
									"});\r",
									"\r",
									"// ИСПРАВЛЕНО: requester содержит сразу ID, а не объект\r",
									"pm.test(\"Requests are from different users\", function () {\r",
									"    const requester1Id = Number(pm.variables.get(\"requester1_id\"));\r",
									"    const requester2Id = Number(pm.variables.get(\"requester2_id\"));\r",
									"    const requesterIds = response.map(r => r.requester); // убрал .id\r",
									"    \r",
									"    pm.expect(requesterIds).to.include(requester1Id);\r",
									"    pm.expect(requesterIds).to.include(requester2Id);\r",
									"});\r",
									"\r",
									"pm.test(\"All requests have status CONFIRMED (auto-accepted)\", function () {\r",
									"    response.forEach(request => {\r",
									"        pm.expect(request.status).to.eql(\"CONFIRMED\");\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamps are valid\", function () {\r",
									"    response.forEach(request => {\r",
									"        const timestamp = new Date(request.created);\r",
									"        pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"        pm.expect(request.created).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/users/{{owner_id}}/events/{{event_id}}/requests",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{owner_id}}",
								"events",
								"{{event_id}}",
								"requests"
							]
						}
					},
					"response": []
				},
				{
					"name": "User get requests for event which is not initiated by him",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"// Создаём трёх пользователей\r",
									"const users = [\r",
									"    { email: `event_owner_${Date.now()}@test.com`, name: \"Event Owner\" },\r",
									"    { email: `requester1_${Date.now()}@test.com`, name: \"Requester 1\" },\r",
									"    { email: `requester2_${Date.now()}@test.com`, name: \"Requester 2\" }\r",
									"];\r",
									"\r",
									"const createdUserIds = [];\r",
									"\r",
									"function createUser(index) {\r",
									"    if (index >= users.length) {\r",
									"        pm.variables.set(\"owner_id\", createdUserIds[0]);\r",
									"        pm.variables.set(\"requester1_id\", createdUserIds[1]);\r",
									"        pm.variables.set(\"requester2_id\", createdUserIds[2]);\r",
									"        console.log(\"User IDs:\", createdUserIds);\r",
									"        \r",
									"        setTimeout(() => {\r",
									"            createEvent();\r",
									"        }, 1000);\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const user = users[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/users`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(user)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании пользователя:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            createdUserIds.push(response.id);\r",
									"        }\r",
									"        createUser(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"function createEvent() {\r",
									"    const owner = createdUserIds[0];\r",
									"    const categoryId = 1;\r",
									"\r",
									"    const event = {\r",
									"        annotation: \"Event for requests test\",\r",
									"        category: categoryId,\r",
									"        description: \"This event is used to test event requests\",\r",
									"        eventDate: \"2025-12-31 15:00:00\",\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: false,\r",
									"        participantLimit: 10,\r",
									"        requestModeration: false,\r",
									"        title: \"Event for Requests Test\"\r",
									"    };\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/users/${owner}/events`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(event)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            pm.variables.set(\"event_id\", response.id);\r",
									"            console.log(\"Создано событие с ID:\", response.id);\r",
									"            \r",
									"            publishEvent(response.id);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function publishEvent(eventId) {\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/events/${eventId}`,\r",
									"        method: 'PATCH',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({\r",
									"            stateAction: \"PUBLISH_EVENT\"\r",
									"        })\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при публикации события:\", err);\r",
									"        } else {\r",
									"            console.log(\"Событие опубликовано\");\r",
									"            \r",
									"            // Оставляем заявки\r",
									"            createRequests(eventId);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function createRequests(eventId) {\r",
									"    const requesters = [createdUserIds[1], createdUserIds[2]];\r",
									"    \r",
									"    function createRequest(index) {\r",
									"        if (index >= requesters.length) {\r",
									"            console.log(\"Все заявки созданы\");\r",
									"            return;\r",
									"        }\r",
									"\r",
									"        const requester = requesters[index];\r",
									"        const url = `${baseUrl}/users/${requester}/requests?eventId=${eventId}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: url,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' }\r",
									"        }, function (err, res) {\r",
									"            if (err) {\r",
									"                console.error(\"Ошибка при создании заявки:\", err);\r",
									"            } else {\r",
									"                const response = res.json();\r",
									"                console.log(`Заявка от пользователя ${requester} создана, ID:`, response.id);\r",
									"            }\r",
									"            createRequest(index + 1);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    createRequest(0);\r",
									"}\r",
									"\r",
									"createUser(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 403 Forbidden\", function () {\r",
									"    pm.response.to.have.status(403);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct error structure\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is FORBIDDEN\", function () {\r",
									"    pm.expect(response.status).to.eql(\"FORBIDDEN\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is For the requested operation the conditions are not met.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"For the requested operation the conditions are not met.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message indicates user is not event initiator\", function () {\r",
									"    const eventId = pm.variables.get(\"event_id\");\r",
									"    const expectedMessage = \"You are not allowed to perform this action. You are not initiator of event: \" + eventId;\r",
									"    pm.expect(response.message).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});\r",
									"\r",
									"console.log(\"✅ Тест пройден - пользователь не может получить заявки на чужое событие\");"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/users/{{requester1_id}}/events/{{event_id}}/requests",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{requester1_id}}",
								"events",
								"{{event_id}}",
								"requests"
							]
						}
					},
					"response": []
				},
				{
					"name": "User confirm 4 requets with limit 2 participant, 2 Confirmd 2r Rejected Automaticly",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"// Создаём 5 пользователей\r",
									"const users = [\r",
									"    { email: `event_owner_${Date.now()}@test.com`, name: \"Event Owner\" },\r",
									"    { email: `requester1_${Date.now()}@test.com`, name: \"Requester 1\" },\r",
									"    { email: `requester2_${Date.now()}@test.com`, name: \"Requester 2\" },\r",
									"    { email: `requester3_${Date.now()}@test.com`, name: \"Requester 3\" },\r",
									"    { email: `requester4_${Date.now()}@test.com`, name: \"Requester 4\" }\r",
									"];\r",
									"\r",
									"const createdUserIds = [];\r",
									"const createdRequestIds = []; // ← добавлено\r",
									"\r",
									"function createUser(index) {\r",
									"    if (index >= users.length) {\r",
									"        pm.variables.set(\"owner_id\", createdUserIds[0]);\r",
									"        pm.variables.set(\"requester1_id\", createdUserIds[1]);\r",
									"        pm.variables.set(\"requester2_id\", createdUserIds[2]);\r",
									"        pm.variables.set(\"requester3_id\", createdUserIds[3]);\r",
									"        pm.variables.set(\"requester4_id\", createdUserIds[4]);\r",
									"        console.log(\"User IDs:\", createdUserIds);\r",
									"        \r",
									"        // Создаём событие от владельца\r",
									"        createEvent();\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    const user = users[index];\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/users`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(user)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании пользователя:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            createdUserIds.push(response.id);\r",
									"        }\r",
									"        createUser(index + 1);\r",
									"    });\r",
									"}\r",
									"\r",
									"function createEvent() {\r",
									"    const owner = createdUserIds[0];\r",
									"    const categoryId = 1;\r",
									"\r",
									"    const event = {\r",
									"        annotation: \"Event with limit 2\",\r",
									"        category: categoryId,\r",
									"        description: \"This event has participant limit 2\",\r",
									"        eventDate: \"2025-12-31 15:00:00\",\r",
									"        location: { lat: 55.754167, lon: 37.62 },\r",
									"        paid: false,\r",
									"        participantLimit: 2, // ← лимит 2\r",
									"        requestModeration: true, // ← с модерацией\r",
									"        title: \"Event with Limit 2\"\r",
									"    };\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/users/${owner}/events`,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(event)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании события:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            pm.variables.set(\"event_id\", response.id);\r",
									"            console.log(\"Создано событие с ID:\", response.id);\r",
									"            \r",
									"            // Публикуем событие\r",
									"            publishEvent(response.id);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function publishEvent(eventId) {\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/events/${eventId}`,\r",
									"        method: 'PATCH',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({\r",
									"            stateAction: \"PUBLISH_EVENT\"\r",
									"        })\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при публикации события:\", err);\r",
									"        } else {\r",
									"            console.log(\"Событие опубликовано\");\r",
									"            \r",
									"            // Оставляем заявки\r",
									"            createRequests(eventId);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function createRequests(eventId) {\r",
									"    const requesters = [\r",
									"        createdUserIds[1],\r",
									"        createdUserIds[2],\r",
									"        createdUserIds[3],\r",
									"        createdUserIds[4]\r",
									"    ];\r",
									"    \r",
									"    function createRequest(index) {\r",
									"        if (index >= requesters.length) {\r",
									"            // Сохраняем ID всех заявок\r",
									"            pm.variables.set(\"request_ids\", createdRequestIds.join(','));\r",
									"            console.log(\"Все заявки созданы, ID:\", createdRequestIds);\r",
									"            return;\r",
									"        }\r",
									"\r",
									"        const requester = requesters[index];\r",
									"        const url = `${baseUrl}/users/${requester}/requests?eventId=${eventId}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: url,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' }\r",
									"        }, function (err, res) {\r",
									"            if (err) {\r",
									"                console.error(\"Ошибка при создании заявки:\", err);\r",
									"            } else {\r",
									"                const response = res.json();\r",
									"                createdRequestIds.push(response.id); // ← сохраняем ID\r",
									"                console.log(`Заявка от пользователя ${requester} создана, ID:`, response.id);\r",
									"            }\r",
									"            createRequest(index + 1);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    createRequest(0);\r",
									"}\r",
									"\r",
									"createUser(0);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure\", function () {\r",
									"    pm.expect(response).to.include.all.keys('confirmedRequests', 'rejectedRequests');\r",
									"});\r",
									"\r",
									"pm.test(\"Confirmed requests array exists\", function () {\r",
									"    pm.expect(Array.isArray(response.confirmedRequests)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Rejected requests array exists\", function () {\r",
									"    pm.expect(Array.isArray(response.rejectedRequests)).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Exactly 2 requests are confirmed\", function () {\r",
									"    pm.expect(response.confirmedRequests.length).to.eql(2);\r",
									"});\r",
									"\r",
									"pm.test(\"Exactly 2 requests are rejected\", function () {\r",
									"    pm.expect(response.rejectedRequests.length).to.eql(2);\r",
									"});\r",
									"\r",
									"pm.test(\"All confirmed requests have status CONFIRMED\", function () {\r",
									"    response.confirmedRequests.forEach(request => {\r",
									"        pm.expect(request.status).to.eql(\"CONFIRMED\");\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"All rejected requests have status REJECTED\", function () {\r",
									"    response.rejectedRequests.forEach(request => {\r",
									"        pm.expect(request.status).to.eql(\"REJECTED\");\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"All requests are for the correct event\", function () {\r",
									"    const eventId = Number(pm.variables.get(\"event_id\"));\r",
									"    [...response.confirmedRequests, ...response.rejectedRequests].forEach(request => {\r",
									"        pm.expect(request.event).to.eql(eventId);\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Requests are from different users\", function () {\r",
									"    const requesterIds = [\r",
									"        Number(pm.variables.get(\"requester1_id\")),\r",
									"        Number(pm.variables.get(\"requester2_id\")),\r",
									"        Number(pm.variables.get(\"requester3_id\")),\r",
									"        Number(pm.variables.get(\"requester4_id\"))\r",
									"    ];\r",
									"    \r",
									"    const actualRequesterIds = [\r",
									"        ...response.confirmedRequests.map(r => r.requester),\r",
									"        ...response.rejectedRequests.map(r => r.requester)\r",
									"    ];\r",
									"    \r",
									"    actualRequesterIds.forEach(id => {\r",
									"        pm.expect(requesterIds).to.include(id);\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamps are valid\", function () {\r",
									"    [...response.confirmedRequests, ...response.rejectedRequests].forEach(request => {\r",
									"        const timestamp = new Date(request.created);\r",
									"        pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"        pm.expect(request.created).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"requestIds\": [{{request_ids}}],\r\n  \"status\": \"CONFIRMED\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/{{owner_id}}/events/{{event_id}}/requests",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{owner_id}}",
								"events",
								"{{event_id}}",
								"requests"
							]
						}
					},
					"response": []
				},
				{
					"name": "User try to patch requests for unmoderated event",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"const ownerId = pm.environment.get(\"owner_id\");\r",
									"const requesterIds = [\r",
									"    pm.environment.get(\"requester1_id\"),\r",
									"    pm.environment.get(\"requester2_id\"),\r",
									"    pm.environment.get(\"requester3_id\"),\r",
									"    pm.environment.get(\"requester4_id\")\r",
									"];\r",
									"\r",
									"const categoryId = 1;\r",
									"const createdRequestIds = []; // ← добавлено\r",
									"\r",
									"const event = {\r",
									"    annotation: \"Event with limit 0\",\r",
									"    category: categoryId,\r",
									"    description: \"This event has participant limit 0\",\r",
									"    eventDate: \"2025-12-31 15:00:00\",\r",
									"    location: { lat: 55.754167, lon: 37.62 },\r",
									"    paid: false,\r",
									"    participantLimit: 0, // ← лимит 0\r",
									"    requestModeration: true,\r",
									"    title: \"Event with Limit 0\"\r",
									"};\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/users/${ownerId}/events`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify(event)\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании события:\", err);\r",
									"    } else {\r",
									"        const response = res.json();\r",
									"        pm.variables.set(\"event_id\", response.id);\r",
									"        console.log(\"Создано событие с ID:\", response.id);\r",
									"        \r",
									"        // Публикуем событие\r",
									"        publishEvent(response.id);\r",
									"    }\r",
									"});\r",
									"\r",
									"function publishEvent(eventId) {\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/events/${eventId}`,\r",
									"        method: 'PATCH',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({\r",
									"            stateAction: \"PUBLISH_EVENT\"\r",
									"        })\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при публикации события:\", err);\r",
									"        } else {\r",
									"            console.log(\"Событие опубликовано\");\r",
									"            \r",
									"            // Оставляем заявки\r",
									"            createRequests(eventId);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function createRequests(eventId) {\r",
									"    function createRequest(index) {\r",
									"        if (index >= requesterIds.length) {\r",
									"            console.log(\"Все заявки созданы, ID:\", createdRequestIds);\r",
									"            \r",
									"            // Сохраняем ID заявок в переменную\r",
									"            pm.variables.set(\"request_ids\", createdRequestIds.join(','));\r",
									"            \r",
									"            // Проверяем confirmedRequests\r",
									"            checkConfirmedRequests(eventId);\r",
									"            return;\r",
									"        }\r",
									"\r",
									"        const requester = requesterIds[index];\r",
									"        const url = `${baseUrl}/users/${requester}/requests?eventId=${eventId}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: url,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' }\r",
									"        }, function (err, res) {\r",
									"            if (err) {\r",
									"                console.error(\"Ошибка при создании заявки:\", err);\r",
									"            } else {\r",
									"                const response = res.json();\r",
									"                createdRequestIds.push(response.id); // ← сохраняем ID\r",
									"                console.log(`Заявка от пользователя ${requester} создана, ID:`, response.id);\r",
									"            }\r",
									"            createRequest(index + 1);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    createRequest(0);\r",
									"}\r",
									"\r",
									"function checkConfirmedRequests(eventId) {\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/events/${eventId}`,\r",
									"        method: 'GET'\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при получении события:\", err);\r",
									"        } else {\r",
									"            console.log(\"Status:\", res.status);\r",
									"            console.log(\"Response:\", JSON.stringify(res.json()));\r",
									"            \r",
									"            if (res.status === 200) {\r",
									"                const response = res.json();\r",
									"                pm.variables.set(\"confirmed_requests\", response.confirmedRequests);\r",
									"                console.log(\"Confirmed requests:\", response.confirmedRequests);\r",
									"            } else {\r",
									"                console.error(\"Не удалось получить событие, статус:\", res.status);\r",
									"                pm.variables.set(\"confirmed_requests\", 4); // fallback\r",
									"            }\r",
									"        }\r",
									"    });\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 409 Conflict\", function () {\r",
									"    pm.response.to.have.status(409);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure for error\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is CONFLICT\", function () {\r",
									"    pm.expect(response.status).to.eql(\"CONFLICT\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is For the requested operation the conditions are not met.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"For the requested operation the conditions are not met.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message indicates request moderation is off or limit = 0\", function () {\r",
									"    const confirmedRequests = Number(pm.variables.get(\"confirmed_requests\"));\r",
									"    const expectedMessage = `Request moderation switched off or Participant limit = 0. Event have ${confirmedRequests} confirmed requests.`;\r",
									"    const actualMessage = response.message;\r",
									"    \r",
									"    // Debug output\r",
									"    console.log(\"Expected message:\", JSON.stringify(expectedMessage));\r",
									"    console.log(\"Actual message:\", JSON.stringify(actualMessage));\r",
									"    console.log(\"Expected length:\", expectedMessage.length);\r",
									"    console.log(\"Actual length:\", actualMessage.length);\r",
									"    \r",
									"    // Посимвольное сравнение\r",
									"    for (let i = 0; i < Math.max(expectedMessage.length, actualMessage.length); i++) {\r",
									"        if (expectedMessage[i] !== actualMessage[i]) {\r",
									"            console.log(`Difference at position ${i}: expected '${expectedMessage[i]}' (${expectedMessage.charCodeAt(i)}), got '${actualMessage[i]}' (${actualMessage.charCodeAt(i)})`);\r",
									"            break;\r",
									"        }\r",
									"    }\r",
									"    \r",
									"    pm.expect(actualMessage).to.eql(expectedMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"requestIds\": [{{request_ids}}],\r\n  \"status\": \"CONFIRMED\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/{{owner_id}}/events/{{event_id}}/requests",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{owner_id}}",
								"events",
								"{{event_id}}",
								"requests"
							]
						}
					},
					"response": []
				},
				{
					"name": "User try confirm request due to participant limit reached",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"const ownerId = pm.environment.get(\"owner_id\");\r",
									"const requesterIds = [\r",
									"    pm.environment.get(\"requester1_id\"),\r",
									"    pm.environment.get(\"requester2_id\"),\r",
									"    pm.environment.get(\"requester3_id\"),\r",
									"    pm.environment.get(\"requester4_id\")\r",
									"];\r",
									"\r",
									"const categoryId = 1;\r",
									"const createdRequestIds = [];\r",
									"\r",
									"const event = {\r",
									"    annotation: \"Event with limit 3\",\r",
									"    category: categoryId,\r",
									"    description: \"This event has participant limit 3\",\r",
									"    eventDate: \"2025-12-31 15:00:00\",\r",
									"    location: { lat: 55.754167, lon: 37.62 },\r",
									"    paid: false,\r",
									"    participantLimit: 3, // ← лимит 3\r",
									"    requestModeration: true, // ← с модерацией\r",
									"    title: \"Event with Limit 3\"\r",
									"};\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/users/${ownerId}/events`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify(event)\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании события:\", err);\r",
									"    } else {\r",
									"        const response = res.json();\r",
									"        pm.variables.set(\"event_id\", response.id);\r",
									"        console.log(\"Создано событие с ID:\", response.id);\r",
									"        \r",
									"        // Публикуем событие\r",
									"        publishEvent(response.id);\r",
									"    }\r",
									"});\r",
									"\r",
									"function publishEvent(eventId) {\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/events/${eventId}`,\r",
									"        method: 'PATCH',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({\r",
									"            stateAction: \"PUBLISH_EVENT\"\r",
									"        })\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при публикации события:\", err);\r",
									"        } else {\r",
									"            console.log(\"Событие опубликовано\");\r",
									"            \r",
									"            // Оставляем заявки от первых 3 пользователей\r",
									"            createRequests(eventId, 3);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function createRequests(eventId, count) {\r",
									"    function createRequest(index) {\r",
									"        if (index >= count) {\r",
									"            console.log(\"Первые 3 заявки созданы\");\r",
									"            \r",
									"            // Подтверждаем их\r",
									"            confirmRequests(eventId);\r",
									"            return;\r",
									"        }\r",
									"\r",
									"        const requester = requesterIds[index];\r",
									"        const url = `${baseUrl}/users/${requester}/requests?eventId=${eventId}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: url,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' }\r",
									"        }, function (err, res) {\r",
									"            if (err) {\r",
									"                console.error(\"Ошибка при создании заявки:\", err);\r",
									"            } else {\r",
									"                const response = res.json();\r",
									"                createdRequestIds.push(response.id);\r",
									"                console.log(`Заявка от пользователя ${requester} создана, ID:`, response.id);\r",
									"            }\r",
									"            createRequest(index + 1);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    createRequest(0);\r",
									"}\r",
									"\r",
									"function confirmRequests(eventId) {\r",
									"    const requestBody = {\r",
									"        requestIds: createdRequestIds,\r",
									"        status: \"CONFIRMED\"\r",
									"    };\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/users/${ownerId}/events/${eventId}/requests`,\r",
									"        method: 'PATCH',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify(requestBody)\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при подтверждении заявок:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            console.log(\"Заявки подтверждены:\", response.confirmedRequests.length);\r",
									"            \r",
									"            // 4-й пользователь оставляет заявку\r",
									"            createLastRequest(eventId);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function createLastRequest(eventId) {\r",
									"    const lastRequester = requesterIds[3];\r",
									"    const url = `${baseUrl}/users/${lastRequester}/requests?eventId=${eventId}`;\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: url,\r",
									"        method: 'POST',\r",
									"        header: { 'Content-Type': 'application/json' }\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при создании последней заявки:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            pm.variables.set(\"last_request_id\", response.id);\r",
									"            console.log(`Последняя заявка от пользователя ${lastRequester} создана, ID:`, response.id);\r",
									"        }\r",
									"    });\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 409 Conflict\", function () {\r",
									"    pm.response.to.have.status(409);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure for error\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is CONFLICT\", function () {\r",
									"    pm.expect(response.status).to.eql(\"CONFLICT\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is For the requested operation the conditions are not met.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"For the requested operation the conditions are not met.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message indicates participant limit exceeded\", function () {\r",
									"    pm.expect(response.message).to.eql(\"Participant limit exceeded\");\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"requestIds\": [{{last_request_id}}],\r\n  \"status\": \"CONFIRMED\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/{{owner_id}}/events/{{event_id}}/requests",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{owner_id}}",
								"events",
								"{{event_id}}",
								"requests"
							]
						}
					},
					"response": []
				},
				{
					"name": "User try to confirm request with canceled status",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const baseUrl = pm.environment.get(\"base_url\");\r",
									"\r",
									"const ownerId = pm.environment.get(\"owner_id\");\r",
									"const requesterIds = [\r",
									"    pm.environment.get(\"requester1_id\"),\r",
									"    pm.environment.get(\"requester2_id\"),\r",
									"    pm.environment.get(\"requester3_id\"),\r",
									"    pm.environment.get(\"requester4_id\")\r",
									"];\r",
									"\r",
									"const categoryId = 1;\r",
									"const createdRequestIds = [];\r",
									"\r",
									"const event = {\r",
									"    annotation: \"Event with limit 5\",\r",
									"    category: categoryId,\r",
									"    description: \"This event has participant limit 5\",\r",
									"    eventDate: \"2025-12-31 15:00:00\",\r",
									"    location: { lat: 55.754167, lon: 37.62 },\r",
									"    paid: false,\r",
									"    participantLimit: 5, // ← лимит 5\r",
									"    requestModeration: true, // ← с модерацией\r",
									"    title: \"Event with Limit 5\"\r",
									"};\r",
									"\r",
									"pm.sendRequest({\r",
									"    url: `${baseUrl}/users/${ownerId}/events`,\r",
									"    method: 'POST',\r",
									"    header: { 'Content-Type': 'application/json' },\r",
									"    body: JSON.stringify(event)\r",
									"}, function (err, res) {\r",
									"    if (err) {\r",
									"        console.error(\"Ошибка при создании события:\", err);\r",
									"    } else {\r",
									"        const response = res.json();\r",
									"        pm.variables.set(\"event_id\", response.id);\r",
									"        console.log(\"Создано событие с ID:\", response.id);\r",
									"        \r",
									"        // Публикуем событие\r",
									"        publishEvent(response.id);\r",
									"    }\r",
									"});\r",
									"\r",
									"function publishEvent(eventId) {\r",
									"    pm.sendRequest({\r",
									"        url: `${baseUrl}/admin/events/${eventId}`,\r",
									"        method: 'PATCH',\r",
									"        header: { 'Content-Type': 'application/json' },\r",
									"        body: JSON.stringify({\r",
									"            stateAction: \"PUBLISH_EVENT\"\r",
									"        })\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при публикации события:\", err);\r",
									"        } else {\r",
									"            console.log(\"Событие опубликовано\");\r",
									"            \r",
									"            // Оставляем заявки от 4 пользователей\r",
									"            createRequests(eventId);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function createRequests(eventId) {\r",
									"    function createRequest(index) {\r",
									"        if (index >= requesterIds.length) {\r",
									"            console.log(\"Все 4 заявки созданы\");\r",
									"            \r",
									"            // 1-й пользователь отменяет свою заявку\r",
									"            cancelRequest(eventId, createdRequestIds[0]);\r",
									"            return;\r",
									"        }\r",
									"\r",
									"        const requester = requesterIds[index];\r",
									"        const url = `${baseUrl}/users/${requester}/requests?eventId=${eventId}`;\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: url,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' }\r",
									"        }, function (err, res) {\r",
									"            if (err) {\r",
									"                console.error(\"Ошибка при создании заявки:\", err);\r",
									"            } else {\r",
									"                const response = res.json();\r",
									"                createdRequestIds.push(response.id);\r",
									"                console.log(`Заявка от пользователя ${requester} создана, ID:`, response.id);\r",
									"            }\r",
									"            createRequest(index + 1);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    createRequest(0);\r",
									"}\r",
									"\r",
									"function cancelRequest(eventId, requestId) {\r",
									"    const requester = requesterIds[0]; // 1-й пользователь\r",
									"    const url = `${baseUrl}/users/${requester}/requests/${requestId}/cancel`;\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: url,\r",
									"        method: 'PATCH',\r",
									"        header: { 'Content-Type': 'application/json' }\r",
									"    }, function (err, res) {\r",
									"        if (err) {\r",
									"            console.error(\"Ошибка при отмене заявки:\", err);\r",
									"        } else {\r",
									"            const response = res.json();\r",
									"            console.log(`Заявка ${requestId} отменена, новый статус:`, response.status);\r",
									"            \r",
									"            // Сохраняем ID отменённой заявки\r",
									"            pm.variables.set(\"cancelled_request_id\", requestId);\r",
									"        }\r",
									"    });\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 409 Conflict\", function () {\r",
									"    pm.response.to.have.status(409);\r",
									"});\r",
									"\r",
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Response has correct structure for error\", function () {\r",
									"    pm.expect(response).to.include.all.keys('status', 'reason', 'message', 'timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Status is CONFLICT\", function () {\r",
									"    pm.expect(response.status).to.eql(\"CONFLICT\");\r",
									"});\r",
									"\r",
									"pm.test(\"Reason is For the requested operation the conditions are not met.\", function () {\r",
									"    pm.expect(response.reason).to.eql(\"For the requested operation the conditions are not met.\");\r",
									"});\r",
									"\r",
									"pm.test(\"Message indicates all requests must be PENDING\", function () {\r",
									"    pm.expect(response.message).to.eql(\"All requests must have status PENDING\");\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp is valid\", function () {\r",
									"    const timestamp = new Date(response.timestamp);\r",
									"    pm.expect(isNaN(timestamp.getTime())).to.be.false;\r",
									"    pm.expect(response.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"requestIds\": [{{cancelled_request_id}}, 2, 3, 4],\r\n  \"status\": \"CONFIRMED\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/users/{{owner_id}}/events/{{event_id}}/requests",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"users",
								"{{owner_id}}",
								"events",
								"{{event_id}}",
								"requests"
							]
						}
					},
					"response": []
				}
			]
		}
	],
	"variable": [
		{
			"key": "confirmed_before",
			"value": ""
		}
	]
}